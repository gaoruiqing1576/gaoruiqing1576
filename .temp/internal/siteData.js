/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "SmallGao",
  "description": "小高的进修",
  "base": "/SmallGao/",
  "headTags": [
    [
      "script",
      {
        "language": "javascript",
        "type": "text/javascript",
        "src": "https://cdn.bootcss.com/jquery/3.6.0/jquery.min.js"
      }
    ],
    [
      "script",
      {
        "language": "javascript",
        "type": "text/javascript",
        "src": "/SmallGao/js/MouseClickEffect.js"
      }
    ]
  ],
  "pages": [
    {
      "title": "不要在命运需要你逆风飞翔时，选择随风而去",
      "frontmatter": {
        "title": "不要在命运需要你逆风飞翔时，选择随风而去",
        "date": "2019-09-28T20:53:26.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20190928.html",
      "relativePath": "views/essay/20190928.md",
      "key": "v-01548842",
      "path": "/views/essay/20190928.html",
      "headers": [
        {
          "level": 2,
          "title": "无聊之时",
          "slug": "无聊之时",
          "normalizedTitle": "无聊之时",
          "charIndex": 2
        }
      ],
      "excerpt": "<Boxx/>\n<h2 id=\"无聊之时\"><a class=\"header-anchor\" href=\"#无聊之时\">#</a> 无聊之时</h2>\n<p>你是否有过这样的经历，在黄昏时分被一种浓浓的情绪气氛笼罩着，无限的压抑、茫然、空虚和无所适从，情感没有依托，你感觉“抓”不住任何东西，世界像个巨大的空洞，任何事物进人，都被消解。你甚至对自己陌生……，你想逃离，它却如影随形。</p>\n",
      "headersStr": "无聊之时",
      "content": "# 无聊之时\n\n你是否有过这样的经历，在黄昏时分被一种浓浓的情绪气氛笼罩着，无限的压抑、茫然、空虚和无所适从，情感没有依托，你感觉“抓”不住任何东西，世界像个巨大的空洞，任何事物进人，都被消解。你甚至对自己陌生……，你想逃离，它却如影随形。\n\n或是在寂静的夜里，你感觉时间滴滴答答仿佛吞噬着你的生命，而你却在窒息的、无能为力的绝望中遇见了另一个自己，那个隐藏的很深的超越你自己的真正的自己。\n\n……\n\n告别无聊：\n\n> 从小事情做起，从细节入手。\n> 首先恢复信心，重新激发生活的热情！你可以采取以下建议：\n\n * You Can Do It！勇敢不是不害怕，而是害怕的时候你还能坚持去做！\n\nTO    DO\n1.    做自己喜欢做的事情，做自己擅长的事情，找回成功的喜悦，找回失去的信心，找到前进动力和方向；\n2.    心累了，人烦恼了就歇歇，让心灵去旅行，可以去爬山，看海，感受壮丽风光，拥抱自然，融入自然；\n3.    可以做喜欢的运动发泄一些，推荐篮球，散步和跑步。跑步可以锻炼身体，锻炼和提高人的意志；\n4.    可以找知心朋友小聚，小酌几杯，向朋友倾诉，让温馨的友情驱散你内心的无聊，苦闷和孤独；\n5.    多和家人聊天，或者打电话，加强沟通，增进感情，告诉家人，我爱他们；\n6.    寻找知心恋人，让爱情升华你的情感，点缀你的生活，照亮你的灵魂；\n7.    如果有什么烦恼不方便和朋友，家人说的，可以上网于陌生人聊天，倾吐一下，也可以找到新的朋友；\n8.    在网上写日记，记下生活的点滴；\n9.    可以和三五知己逛街购物，说不定有意外的便宜货或者意外的美食在等着你，从中你可以收获意外的惊喜;\n10.   好好学习，找到学习的乐趣，不断进步，提高自己的学习成绩，结合自己的兴趣多看有关书籍，规划好自己的专业和就业道路，规划好自己的人生道路；\n11.   可以和家人适当地观看自己喜爱的电视剧，同时又可以和家人聊聊天，增进感情；\n12.   可以阅读自己感兴趣的书籍，开拓视野，增长见闻，丰富知识，为学习和工作打下良好的基础；\n13.   可以练练书法，画画，钢琴或者其它乐器，陶冶情操，增加气质；\n14.   提倡绿色上网，看看新闻，适当玩玩游戏，但是不是沉迷，这样可以打发时间；\n15.   适当地在家里做家务，这样既可以保持卫生，有可以得到家人的赞扬，可以得到生活的乐趣；\n16.   夕阳西下，来到野外寻找蒲公英，对着夕阳，迎着晚风轻轻一吹，那就是我飞扬的蒲公英；\n17.   睡不着的时候，可以想象你可以让谁开心，帮助别人是对自己最大的回报！\n\nOK，写给自己同时分享给别人，以后无聊的时候不要再没事做啦！",
      "normalizedContent": "# 无聊之时\n\n你是否有过这样的经历，在黄昏时分被一种浓浓的情绪气氛笼罩着，无限的压抑、茫然、空虚和无所适从，情感没有依托，你感觉“抓”不住任何东西，世界像个巨大的空洞，任何事物进人，都被消解。你甚至对自己陌生……，你想逃离，它却如影随形。\n\n或是在寂静的夜里，你感觉时间滴滴答答仿佛吞噬着你的生命，而你却在窒息的、无能为力的绝望中遇见了另一个自己，那个隐藏的很深的超越你自己的真正的自己。\n\n……\n\n告别无聊：\n\n> 从小事情做起，从细节入手。\n> 首先恢复信心，重新激发生活的热情！你可以采取以下建议：\n\n * you can do it！勇敢不是不害怕，而是害怕的时候你还能坚持去做！\n\nto    do\n1.    做自己喜欢做的事情，做自己擅长的事情，找回成功的喜悦，找回失去的信心，找到前进动力和方向；\n2.    心累了，人烦恼了就歇歇，让心灵去旅行，可以去爬山，看海，感受壮丽风光，拥抱自然，融入自然；\n3.    可以做喜欢的运动发泄一些，推荐篮球，散步和跑步。跑步可以锻炼身体，锻炼和提高人的意志；\n4.    可以找知心朋友小聚，小酌几杯，向朋友倾诉，让温馨的友情驱散你内心的无聊，苦闷和孤独；\n5.    多和家人聊天，或者打电话，加强沟通，增进感情，告诉家人，我爱他们；\n6.    寻找知心恋人，让爱情升华你的情感，点缀你的生活，照亮你的灵魂；\n7.    如果有什么烦恼不方便和朋友，家人说的，可以上网于陌生人聊天，倾吐一下，也可以找到新的朋友；\n8.    在网上写日记，记下生活的点滴；\n9.    可以和三五知己逛街购物，说不定有意外的便宜货或者意外的美食在等着你，从中你可以收获意外的惊喜;\n10.   好好学习，找到学习的乐趣，不断进步，提高自己的学习成绩，结合自己的兴趣多看有关书籍，规划好自己的专业和就业道路，规划好自己的人生道路；\n11.   可以和家人适当地观看自己喜爱的电视剧，同时又可以和家人聊聊天，增进感情；\n12.   可以阅读自己感兴趣的书籍，开拓视野，增长见闻，丰富知识，为学习和工作打下良好的基础；\n13.   可以练练书法，画画，钢琴或者其它乐器，陶冶情操，增加气质；\n14.   提倡绿色上网，看看新闻，适当玩玩游戏，但是不是沉迷，这样可以打发时间；\n15.   适当地在家里做家务，这样既可以保持卫生，有可以得到家人的赞扬，可以得到生活的乐趣；\n16.   夕阳西下，来到野外寻找蒲公英，对着夕阳，迎着晚风轻轻一吹，那就是我飞扬的蒲公英；\n17.   睡不着的时候，可以想象你可以让谁开心，帮助别人是对自己最大的回报！\n\nok，写给自己同时分享给别人，以后无聊的时候不要再没事做啦！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "牢骚太盛防肠断，风物长宜放眼量",
      "frontmatter": {
        "title": "牢骚太盛防肠断，风物长宜放眼量",
        "date": "2019-12-16T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20191116.html",
      "relativePath": "views/essay/20191116.md",
      "key": "v-425474f3",
      "path": "/views/essay/20191116.html",
      "headers": [
        {
          "level": 2,
          "title": "游戏",
          "slug": "游戏",
          "normalizedTitle": "游戏",
          "charIndex": 187
        },
        {
          "level": 2,
          "title": "订阅号",
          "slug": "订阅号",
          "normalizedTitle": "订阅号",
          "charIndex": 482
        }
      ],
      "headersStr": "游戏 订阅号",
      "content": "“牢骚太盛防肠断，风物长宜放眼量” ——出自《赠柳亚子先生》\n\n意思是：你遇到一些不顺心的事，牢骚太多了，要提防有碍身心健康，对一切风光景物要放开眼界去衡量。\n\n这句诗是针对柳亚子来诗所表现的思想情绪进行正面的批评和规劝。诗人说，应该放开眼界，从远处，大处着眼，也就是从未来从全局着眼，胸襟开阔，保持健康的心态。\n\n而闲来无事的我也只能写写东西发发牢骚来解解闷啦~\n\n\n# 游戏\n\n今天和基友开了两把，爽了一番，心情很是舒畅。\n\n\n\n作为王者多赛季最强王者资深老玩家，装了卸，卸了装，一次又一次。相信不少人对这个游戏是既爱又恨，爱它给我带来的身心放松、精神享受，恨它给我带来的愧疚不堪、萎靡不振！\n\n每当我意识到这个问题，常常是懊悔不已。几次下定决心退出，奈何不如人意。\n\n故，此次，一定，必须，是我的最后一次。\n\n也致我亲爱的基友们：希望你们下次开玩时千万不要喊我，更不要说 等你 这两个字眼，唉哟，最受不了这个了。\n\n放弃这些无意义的游戏之后，准备转战写作剪辑方向了，闲来无事拍拍照片，练练文笔，捎带着思考一下人生，这一天不也就这么过去了嘛！捂脸笑！\n\n\n# 订阅号\n\n说到订阅号不得不吐槽一下微信新版订阅号展示逻辑问题，让我使用起来非常难受，借用知友的回答：\n\n\n\n确实，之前的订阅号列表就像是我关注的微博博主，常常是因为我对这个人感兴趣，然后他更新了信息，我才会去主动点进列表页面去观看他的相关消息。\n\n而现在的订阅号更多的是从订阅号作者角度出发，以信息流的方式展示给我们，不管质量好坏和我们是否喜欢，作为用户我们只能被动接受这些消息，较比之前不能主动选择（还需要按右上角进入订阅号列表，对我来说太难了），让人十分难受。\n\n当然，这从订阅号作者角度出发来说是好的，因为这种信息流的方式增加了你文章的曝光率，只要你的内容足够优秀，你会引来大批的追随者。\n\n相信这也是微信交互设计师权衡之后决定的吧，牺牲部分用户体验，加强订阅号生态质量。\n\n话说回来订阅号也准备改版了，就同博客（znote）同步更新吧，从资料、笔记、学习出发，整理知识，梳理架构，就先从随笔开始吧。",
      "normalizedContent": "“牢骚太盛防肠断，风物长宜放眼量” ——出自《赠柳亚子先生》\n\n意思是：你遇到一些不顺心的事，牢骚太多了，要提防有碍身心健康，对一切风光景物要放开眼界去衡量。\n\n这句诗是针对柳亚子来诗所表现的思想情绪进行正面的批评和规劝。诗人说，应该放开眼界，从远处，大处着眼，也就是从未来从全局着眼，胸襟开阔，保持健康的心态。\n\n而闲来无事的我也只能写写东西发发牢骚来解解闷啦~\n\n\n# 游戏\n\n今天和基友开了两把，爽了一番，心情很是舒畅。\n\n\n\n作为王者多赛季最强王者资深老玩家，装了卸，卸了装，一次又一次。相信不少人对这个游戏是既爱又恨，爱它给我带来的身心放松、精神享受，恨它给我带来的愧疚不堪、萎靡不振！\n\n每当我意识到这个问题，常常是懊悔不已。几次下定决心退出，奈何不如人意。\n\n故，此次，一定，必须，是我的最后一次。\n\n也致我亲爱的基友们：希望你们下次开玩时千万不要喊我，更不要说 等你 这两个字眼，唉哟，最受不了这个了。\n\n放弃这些无意义的游戏之后，准备转战写作剪辑方向了，闲来无事拍拍照片，练练文笔，捎带着思考一下人生，这一天不也就这么过去了嘛！捂脸笑！\n\n\n# 订阅号\n\n说到订阅号不得不吐槽一下微信新版订阅号展示逻辑问题，让我使用起来非常难受，借用知友的回答：\n\n\n\n确实，之前的订阅号列表就像是我关注的微博博主，常常是因为我对这个人感兴趣，然后他更新了信息，我才会去主动点进列表页面去观看他的相关消息。\n\n而现在的订阅号更多的是从订阅号作者角度出发，以信息流的方式展示给我们，不管质量好坏和我们是否喜欢，作为用户我们只能被动接受这些消息，较比之前不能主动选择（还需要按右上角进入订阅号列表，对我来说太难了），让人十分难受。\n\n当然，这从订阅号作者角度出发来说是好的，因为这种信息流的方式增加了你文章的曝光率，只要你的内容足够优秀，你会引来大批的追随者。\n\n相信这也是微信交互设计师权衡之后决定的吧，牺牲部分用户体验，加强订阅号生态质量。\n\n话说回来订阅号也准备改版了，就同博客（znote）同步更新吧，从资料、笔记、学习出发，整理知识，梳理架构，就先从随笔开始吧。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/03/18, 15:41:04",
      "lastUpdatedTimestamp": 1647589264000
    },
    {
      "title": "概览",
      "frontmatter": {
        "title": "概览",
        "sidebar": true,
        "date": "2019-08-21T00:00:00.000Z",
        "sidebarDepth": 0,
        "isShowComments": true
      },
      "regularPath": "/views/",
      "relativePath": "views/README.md",
      "key": "v-0e1e21ed",
      "path": "/views/",
      "headersStr": null,
      "content": " \n \n \n远航\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n风吹雨打不退让\n \n无论我去到哪方\n心里梦想不变样\n是新生 是醒觉\n梦想永远在世上\n \n前路哪怕远 只要自强\n我继续独自寻路向\n常为以往梦想发狂\n耐心摸索路途上\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n途人路上回望我\n只因我的怪模样\n途人谁能明白我\n今天眼睛多雪亮\n \n人是各有各理想\n奔向目标不退让\n用歌声 用欢笑\n来博知音的赞赏\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n依照心中那 正确方向\n \n怀着爱与恕的心\n充满梦想的笑着\n用歌声 用欢笑\n来博知音的赞赏\n \n\n【分类】\n\n【标签】\n\n【前端】 | 【后端】\n\n【规范】 | 【随笔】",
      "normalizedContent": " \n \n \n远航\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n风吹雨打不退让\n \n无论我去到哪方\n心里梦想不变样\n是新生 是醒觉\n梦想永远在世上\n \n前路哪怕远 只要自强\n我继续独自寻路向\n常为以往梦想发狂\n耐心摸索路途上\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n途人路上回望我\n只因我的怪模样\n途人谁能明白我\n今天眼睛多雪亮\n \n人是各有各理想\n奔向目标不退让\n用歌声 用欢笑\n来博知音的赞赏\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n依照心中那 正确方向\n \n怀着爱与恕的心\n充满梦想的笑着\n用歌声 用欢笑\n来博知音的赞赏\n \n\n【分类】\n\n【标签】\n\n【前端】 | 【后端】\n\n【规范】 | 【随笔】",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2023/07/17, 14:43:06",
      "lastUpdatedTimestamp": 1689576186000
    },
    {
      "title": "末年初雪至",
      "frontmatter": {
        "title": "末年初雪至",
        "date": "2019-11-30T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20191130.html",
      "relativePath": "views/essay/20191130.md",
      "key": "v-70ad3afa",
      "path": "/views/essay/20191130.html",
      "headers": [
        {
          "level": 2,
          "title": "初雪",
          "slug": "初雪",
          "normalizedTitle": "初雪",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "计划",
          "slug": "计划",
          "normalizedTitle": "计划",
          "charIndex": 280
        },
        {
          "level": 2,
          "title": "随笔小结",
          "slug": "随笔小结",
          "normalizedTitle": "随笔小结",
          "charIndex": 384
        },
        {
          "level": 2,
          "title": "其他",
          "slug": "其他",
          "normalizedTitle": "其他",
          "charIndex": 268
        }
      ],
      "excerpt": "<Boxx/>\n<h2 id=\"初雪\"><a class=\"header-anchor\" href=\"#初雪\">#</a> 初雪</h2>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/lmNRgg.png\" alt=\"lmNRgg.png\" /></p>\n<p>自昨晚就从朋友圈刷屁屁的雪，也是累坏了一群人，看给孩子高兴的。</p>\n",
      "headersStr": "初雪 计划 随笔小结 其他",
      "content": "# 初雪\n\n\n\n自昨晚就从朋友圈刷屁屁的雪，也是累坏了一群人，看给孩子高兴的。\n\n今早还睡意朦胧的时候，就听见屋外铁锹稀里咣当的声音，掀开窗户一看，啧啧啧，屋外已是一偏雪景，开心。\n\n于是赶紧打开电脑，深吸一口仙气，准备发一篇万字长文来表达我一下此时此刻激动的心情（/激动脸）。\n\n\n\n红墙飞白雪，这个简直就是帝都的风雪标志，下雪天的时候人不多，拍照、观景估计都是不错的，可惜媳妇儿上班班，唉，不然来一次雪中漫步可能也不错吧，哈哈哈~\n\n随着初雪已致，2019尾声悄然到来，仿佛也在跟我说：臭小子，准备好迎接2020吧。\n\n然后就是一些其他的牢骚了。\n\n\n# 计划\n\n说起来真的是有好多事情没有做呢，年末总结没有动，计划单没有写，项目梳理还不完善，光是想想就疯了。（一脸的不情愿）\n\n没办法，得交点东西出来呀，只好先截个脑图了，暂且算是对自己的草草交代。\n\n\n\n\n# 随笔小结\n\n前言：随笔这个东西，不是那么简单唷。。\n\n学生时代，没事搞个命题作文来应付应付考试，顺带还能展示展示风采！职场时光，执笔次数都屈指可数，文采更是大不如从前，还风采...，依旧？更多的是记录一些生活的感悟，以及经历，想想真是挺怀念以前的在校生活呀！！\n\n刚开始的时候也是抽空挤时间东一句西一句的凑，但是后来慢慢发现写作这个东西，就跟待人待事一样，需要拿出专门的时间思考，下笔，修改，再修改。\n\n平时灵感来了记录一下，时间到了就静下心来好好写。\n\n现在很少能沉静下来，闲余时间不是在刷手机就是在刷手机的路上，安静下来读一本书都很难，甚至最近都没有好好听一首歌，就是那种融入到歌曲里面，神游天外的感觉。\n\n所以最近我在努力，努力，努力找寻属于自己的 “静”。\n\n静，则光通达。什么是静，一个人内心很沉静的时候，你的内心就会很纯洁，就像池塘的水一样，当池塘的水很静的时候，它往往污泥什么的都沉淀了，你能够一眼看到底，所以保持内心的沉静，于是，静则光通达。——陈果\n\n怎么样，读书有用了吧，将别人的知识点引入到自己的文章中去，并加以修饰，这就是我们自己的东西，发光了别人，强大了自己。\n\n这里不由得推荐一下 old Chinese person，网易云歌单ID：3068309305，每次写点东西的时候总得听着它才能有孜孜不倦的灵感，是从友人那儿偷来的，真的是一首能让人静下心来的神曲！\n\n\n# 其他\n\n有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧。\n\n以上几位都是我喜欢的歌手，熟悉我的朋友都知道，之前非常喜欢许巍，故乡、像风一样自由，都是我K歌必点歌曲，唱K时也能唱好它，是因为我感觉我就是曲中之魂，嗨歌时更有一种身临其境之感，也总能把自己带入歌曲的那种情景中去，仿佛自己就是其中的主人公。\n\n但是现在再听，已完全没有当时的那种触动感，一度怀疑是不是工作之后劳碌的我没有了当年的热枕（哭笑脸），同时，期待可以遇见那么一首歌，能够唤起我的回忆。\n\n所以，保持内心的沉静。（昨晚下单了XS，%@3&……，怎么让我保持沉静！）\n\n就这样吧，北京的初雪，11月底12月初，19年末20年始，一切都是那么的刚刚好！",
      "normalizedContent": "# 初雪\n\n\n\n自昨晚就从朋友圈刷屁屁的雪，也是累坏了一群人，看给孩子高兴的。\n\n今早还睡意朦胧的时候，就听见屋外铁锹稀里咣当的声音，掀开窗户一看，啧啧啧，屋外已是一偏雪景，开心。\n\n于是赶紧打开电脑，深吸一口仙气，准备发一篇万字长文来表达我一下此时此刻激动的心情（/激动脸）。\n\n\n\n红墙飞白雪，这个简直就是帝都的风雪标志，下雪天的时候人不多，拍照、观景估计都是不错的，可惜媳妇儿上班班，唉，不然来一次雪中漫步可能也不错吧，哈哈哈~\n\n随着初雪已致，2019尾声悄然到来，仿佛也在跟我说：臭小子，准备好迎接2020吧。\n\n然后就是一些其他的牢骚了。\n\n\n# 计划\n\n说起来真的是有好多事情没有做呢，年末总结没有动，计划单没有写，项目梳理还不完善，光是想想就疯了。（一脸的不情愿）\n\n没办法，得交点东西出来呀，只好先截个脑图了，暂且算是对自己的草草交代。\n\n\n\n\n# 随笔小结\n\n前言：随笔这个东西，不是那么简单唷。。\n\n学生时代，没事搞个命题作文来应付应付考试，顺带还能展示展示风采！职场时光，执笔次数都屈指可数，文采更是大不如从前，还风采...，依旧？更多的是记录一些生活的感悟，以及经历，想想真是挺怀念以前的在校生活呀！！\n\n刚开始的时候也是抽空挤时间东一句西一句的凑，但是后来慢慢发现写作这个东西，就跟待人待事一样，需要拿出专门的时间思考，下笔，修改，再修改。\n\n平时灵感来了记录一下，时间到了就静下心来好好写。\n\n现在很少能沉静下来，闲余时间不是在刷手机就是在刷手机的路上，安静下来读一本书都很难，甚至最近都没有好好听一首歌，就是那种融入到歌曲里面，神游天外的感觉。\n\n所以最近我在努力，努力，努力找寻属于自己的 “静”。\n\n静，则光通达。什么是静，一个人内心很沉静的时候，你的内心就会很纯洁，就像池塘的水一样，当池塘的水很静的时候，它往往污泥什么的都沉淀了，你能够一眼看到底，所以保持内心的沉静，于是，静则光通达。——陈果\n\n怎么样，读书有用了吧，将别人的知识点引入到自己的文章中去，并加以修饰，这就是我们自己的东西，发光了别人，强大了自己。\n\n这里不由得推荐一下 old chinese person，网易云歌单id：3068309305，每次写点东西的时候总得听着它才能有孜孜不倦的灵感，是从友人那儿偷来的，真的是一首能让人静下心来的神曲！\n\n\n# 其他\n\n有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧。\n\n以上几位都是我喜欢的歌手，熟悉我的朋友都知道，之前非常喜欢许巍，故乡、像风一样自由，都是我k歌必点歌曲，唱k时也能唱好它，是因为我感觉我就是曲中之魂，嗨歌时更有一种身临其境之感，也总能把自己带入歌曲的那种情景中去，仿佛自己就是其中的主人公。\n\n但是现在再听，已完全没有当时的那种触动感，一度怀疑是不是工作之后劳碌的我没有了当年的热枕（哭笑脸），同时，期待可以遇见那么一首歌，能够唤起我的回忆。\n\n所以，保持内心的沉静。（昨晚下单了xs，%@3&……，怎么让我保持沉静！）\n\n就这样吧，北京的初雪，11月底12月初，19年末20年始，一切都是那么的刚刚好！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "超级无敌睡眠法则",
      "frontmatter": {
        "title": "超级无敌睡眠法则",
        "date": "2020-02-27T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20200227.html",
      "relativePath": "views/essay/20200227.md",
      "key": "v-a8f65c7a",
      "path": "/views/essay/20200227.html",
      "headers": [
        {
          "level": 2,
          "title": "姿势",
          "slug": "姿势",
          "normalizedTitle": "姿势",
          "charIndex": 132
        },
        {
          "level": 2,
          "title": "放松",
          "slug": "放松",
          "normalizedTitle": "放松",
          "charIndex": 174
        },
        {
          "level": 2,
          "title": "呼吸",
          "slug": "呼吸",
          "normalizedTitle": "呼吸",
          "charIndex": 163
        }
      ],
      "excerpt": "<Boxx/>\n<br/>\n<ul>\n<li>\n<p>你睡了么，可惜我失眠了 -</p>\n<p>终于，我这么没心没肺连梦都不做的人也失眠了😭...</p>\n<p>谁能告诉我该怎么办，接连好几天了额，太太太痛苦了~</p>\n</li>\n</ul>\n",
      "headersStr": "姿势 放松 呼吸",
      "content": "\n\n\n * 你睡了么，可惜我失眠了 -\n   \n   终于，我这么没心没肺连梦都不做的人也失眠了😭...\n   \n   谁能告诉我该怎么办，接连好几天了额，太太太痛苦了~\n\n\n\n网上查了一下，最近压力🍐大？好嘛，么得办法，自我总结一套睡眠法则💪💪\n\n\n# 姿势\n\n 1. 全身平躺，双手自然放下\n\n 2. 脑子放空，深呼吸👃一次\n\n\n# 放松\n\n 1. 脑子放空，5秒的 深呼吸 一次\n\n 2. 集中注意力，放在脑子里，告诉自己全身开始 放松\n    [1] 慢慢的，将注意力集中到脚部，脚开始放松\n    [2] 慢慢的，随着注意力来到小腿部，小腿放松\n    [3] 慢慢的，随之来到大腿部，大腿放松\n    [4] 慢慢的，来到臀部，臀部放松\n    [5] 慢慢的，来到腰部，腰部放松\n    [6] 慢慢的，来到手臂处，手臂放松\n    [7] 慢慢的，来到肩膀处，肩膀放松\n    [8] 慢慢的，回到头部，放松...\n\n\n# 呼吸\n\n 1. 然后保持 478呼吸法 来帮助睡眠（可依据个人调整为456呼吸等）\n    [1] 吸气⏪，1，2，3，4\n    [2] 停气🤫，1，2，3，4，5，6，7\n    [3] 呼气⏩，1，2，3，4，5，6，7，8\n    [4] 吸气⏪，1，2，3，4\n    [5] 停气🤫，1，2，3，4，5，6，7\n    [6] 呼气⏩，1，2，3，4，5，6，7，8\n    [7] 吸气⏪，1，2，3，4\n    [8] 停气🤫，1，2，3，4，5，6，7\n    [9] 呼气⏩，1，2，3，4，5，6，7，8\n    [10] 如此反复 ⏪🤫⏩ ...\n    \n\n * 安静的，睡吧~ 睡吧~ 😴😴🌙\n\n本人夜观天象，觉今日晚10:10乃是睡觉吉时，睡个好觉妥妥的。",
      "normalizedContent": "\n\n\n * 你睡了么，可惜我失眠了 -\n   \n   终于，我这么没心没肺连梦都不做的人也失眠了😭...\n   \n   谁能告诉我该怎么办，接连好几天了额，太太太痛苦了~\n\n\n\n网上查了一下，最近压力🍐大？好嘛，么得办法，自我总结一套睡眠法则💪💪\n\n\n# 姿势\n\n 1. 全身平躺，双手自然放下\n\n 2. 脑子放空，深呼吸👃一次\n\n\n# 放松\n\n 1. 脑子放空，5秒的 深呼吸 一次\n\n 2. 集中注意力，放在脑子里，告诉自己全身开始 放松\n    [1] 慢慢的，将注意力集中到脚部，脚开始放松\n    [2] 慢慢的，随着注意力来到小腿部，小腿放松\n    [3] 慢慢的，随之来到大腿部，大腿放松\n    [4] 慢慢的，来到臀部，臀部放松\n    [5] 慢慢的，来到腰部，腰部放松\n    [6] 慢慢的，来到手臂处，手臂放松\n    [7] 慢慢的，来到肩膀处，肩膀放松\n    [8] 慢慢的，回到头部，放松...\n\n\n# 呼吸\n\n 1. 然后保持 478呼吸法 来帮助睡眠（可依据个人调整为456呼吸等）\n    [1] 吸气⏪，1，2，3，4\n    [2] 停气🤫，1，2，3，4，5，6，7\n    [3] 呼气⏩，1，2，3，4，5，6，7，8\n    [4] 吸气⏪，1，2，3，4\n    [5] 停气🤫，1，2，3，4，5，6，7\n    [6] 呼气⏩，1，2，3，4，5，6，7，8\n    [7] 吸气⏪，1，2，3，4\n    [8] 停气🤫，1，2，3，4，5，6，7\n    [9] 呼气⏩，1，2，3，4，5，6，7，8\n    [10] 如此反复 ⏪🤫⏩ ...\n    \n\n * 安静的，睡吧~ 睡吧~ 😴😴🌙\n\n本人夜观天象，觉今日晚10:10乃是睡觉吉时，睡个好觉妥妥的。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "汝之为何 吾之奈何",
      "frontmatter": {
        "title": "汝之为何 吾之奈何",
        "date": "2020-03-01T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "keys": [
          "5201314"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20200301.html",
      "relativePath": "views/essay/20200301.md",
      "key": "v-0ca1c3ee",
      "path": "/views/essay/20200301.html",
      "headers": [
        {
          "level": 2,
          "title": "伤脑",
          "slug": "伤脑",
          "normalizedTitle": "伤脑",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "热狗之应",
          "slug": "热狗之应",
          "normalizedTitle": "热狗之应",
          "charIndex": 101
        },
        {
          "level": 2,
          "title": "最后的总结",
          "slug": "最后的总结",
          "normalizedTitle": "最后的总结",
          "charIndex": 2590
        },
        {
          "level": 2,
          "title": "气之因 行之果",
          "slug": "气之因-行之果",
          "normalizedTitle": "气之因 行之果",
          "charIndex": 2943
        }
      ],
      "headersStr": "伤脑 热狗之应 最后的总结 气之因 行之果",
      "content": "# 伤脑\n\n女朋友生气了，而你毫无察觉。等到你看到女友那哀怨的小眼神，你才知道事情不妙，女朋友生气了。 问题的关键是，你觉得你压根就没有惹她。 故，今天，伤脑筋的是：女朋友生气了怎么办? 😱\n\n\n# 热狗之应\n\n女朋友生气的时候，或许你很莫名其妙，或许你很不理解，或许你还很心累很烦躁，但绝不要让自己的情绪被她更强烈的负面情绪带走。 或许她说话带刺，很难听，很伤人，也或许她的态度让人很不舒服，对你冷暴力，这时候万万不可动怒，一旦你也生气了，两人势必大吵一架，大吵之后若不能得到良好处理，就可能会产生感情隔阂，两人之间存在了不能触碰的禁区，显然会对日后分手埋下伏笔。\n\n所以你首先不能让自己产生情绪。\n\n发现女朋友生气了，首先你要理性地想，又来了，又耍小孩子脾气了，又要满嘴气话了，真拿这孩子没办法，好好哄吧。 没错，你要全程保持理性，跳出事件本身，清楚她说的难听的话都是气话，该想的是她为什么生气，这次该怎么哄，如何处理好她的这次生气。\n\n当然，如果真的很难忍，你还是爆炸了，那就尽兴大吵一架吧。不过等你冷静了，你还是得继续放下面子按以下步骤去哄。\n\n第一步 发现原因 对症下药 认真解释\n\n我怎么知道她为什么生气呢？ 这需要直男的你好好锻炼，日后慢慢get到你女朋友的生气点。 那最初小白的你怎么去了解呢？ 当然还得问她本人。\n\n如果你不是故意犯错，同时你真的直到实在不知道女朋友为什么生气，你完全可以拿出你最诚恳的态度去问。 必须是掏心肺腑的诚恳。 如果你单纯一句，宝贝，发生什么了，我到底哪儿做错了？ 可能只能得到一句反问，你居然不知道你哪儿错了？ 随后一句，你自己想，好好想想哪儿错了。 你只能原地懵逼百思不得解。\n\n拿出最诚恳的态度掏心肺腑地问应该是这样的。 宝贝，可能真的是我太笨太蠢了，我实在想不明白宝贝为什么生气，如果是因为我的问题，一定告诉我好吗，是我哪里考虑的太少，惹宝贝生气了？我总是很迟钝，一直不懂女孩子的心，可以给我一点点耐心吗？\n\n像这样把你真实心理过程掏心肺腑给她说，尽可能多地说，让她相信你是真不知道，你真是钢铁直男，那就没办法了只好告诉你了。\n\n知道了原因后必须对症下药，解释清楚。 为什么错了，为什么发生了，起因经过结尾，以及自己的全部心理过程。 没错这又是一个掏心肺腑的过程，要把自己的所有心里想法全透明给她。 当时怎么想的，之后怎么想的，为什么会发生这样的事，具体到每个细节，原原本本地说清楚。 如果你是冤枉的，就务必这样解释清楚，如果你真的有错，讲清情况后要立刻承认错误。 如果你的女朋友也很理性，能明事理，这样解释应该就可以解决问题。 但大多数不能，会认死理，要面子等等，那就要进行下一步。\n\n第二步 深情吐露心声\n\n这个标题感觉好违和。 先听我慢慢说吧。\n\n解释清楚后，就不要再拘泥于她生气的原因了，别揪着一个点再翻来覆去解释，只会越解释她越烦。\n\n在明了过程后，如果她还生气，可能是以下三个原因，一原因已经发生变化，比如你之后的态度不好之类，二可能是认死理，不行你犯了错咱俩就不能好了，三可能是爱面子，不行这事没完你得哄我。 无论哪种情况这时候都该进入哄的正题了。\n\n深情告白嘛就是再掏心肺腑地表达你有么多爱她，你有么多在乎她，你有多么重视她，这绝对是每个女孩子最想听的。\n\n直男不会花言巧语，就该掏心肺腑，而且女生相比花言巧语，更喜欢真实想法。就类似之前解释原因一样，你把重视她在乎她的心理过程再加进去，表达出你其实一直都是在想着她考虑着她，只是有时候方式方法出现了问题，你以后不会这样了。\n\n当然你可以跳出这件事，举例一些别的事，或者不具体到事，让她知道在你心里她多么重要，让她知道她的情绪总在影响着你的情绪，让她知道她开心你也开心，她不开心你也不开心，希望你可以让她总是有好心情，而不像这样因为自己而不高兴，让她知道她对你来说多么多么重要。 这里说的别俗套，把自己的真实想法说清楚就好。\n\n你爱他的时候，每个发自心底的想法都可以是好听的情话，即使表达拙劣一点，也会很感人。\n\n第三步 厚脸皮地哄她开心\n\n有时候，你深情太多，会显得自己很卑微，像个小丑一样在求她，这种时候不仅你自己会产生负面情绪，她也会有，会让她心里烦躁，感到有负担。你继续掏心肺腑反倒会换来她的不舒服，感觉跟你在一起是对你多大的亏欠。 所以你要及时切换心情，变成一个坏坏的，厚脸皮的，或者霸道的男友形象。 这时候必须已经过了她的气头，而在她单纯耍脾气求哄阶段。 怎么操作呢，夸她，各种夸张各种不要脸地夸，说难听点，就像卖国求荣的汉奸在讨好小日本。 然后就是说自己的不是，说自己蠢说自己笨，求包容求原谅。 然后再不停夸她，啊呀老婆最美最贤惠最善良天下第一好，得此良妻犹有何憾？ 啊呀宝贝最乖最可爱。 以后保证好好听你的。 乖，别闹了，听话。 你是我的，别想跑。 诸如此类。\n\n有时候哄女朋友不是你要哄到什么点哄到什么程度的问题，而是你要积累哄的时间，拿出你认真哄的态度给她看，这也是证明你多重视她的过程。\n\n第四步 事后沟通总结 我一直觉得情侣之间无论如何沟通最重要，尤其是异地恋。 包括之前说的，一旦你也爆炸了两人大吵一架，事后冷静了哄好后必须沟通好，必须针对此事好好谈谈交换想法，修补可能存在的裂缝。\n\n包括她生气了你单方面哄（她依然会觉得这是你们两人在吵架），哄完了你们也需要沟通，说说你们关于这件事的真实想法，说说两人以后怎么做。 遇到问题必须解决。\n\n当然，有些话你还是不敢对她说。 我替你说。\n\n哄女朋友确实是男朋友应该有的技能，尤其是异地恋，更容易缺乏安全感，再加上看着别的情侣秀恩爱，女孩子会更加觉得缺爱，所以会生气烦躁闹脾气很正常。\n\n可是啊，真的不要太作，一次两次或许可以接受，隔三差五的来，真的受不了，说不好听的，男朋友再好，再爱你，再温柔，迟早有一天也会给作没了。\n\n有的男生很直，很幼稚，很自私，但他们会为了女朋友在努力改变。 女生也会幼稚，也会自私，所以会作，会整天揪着他到底爱不爱我，有多在乎我，是不是没当初那么重视我了，然后以此去为难男朋友。\n\n即使像上述生气到哄的过程，也会耗费两人尤其是男生许多时间精力，这样的情况多了必然会影响到正常的生活。 两个人应该多些平等，多些理解，多些沟通，都该因为在一起而有所成长。\n\n\n# 最后的总结\n\n不管女朋友心情不好，无理取闹，还是你做错了事，你只要记住第一件事“你错了”。男人嘛，要大度一点。她很在意你此时的态度，如果你不理她或者一走了之，那我很悲伤地告诉你，你倒霉了。\n\n讲笑话，扮鬼脸，怎么搞笑怎么来，如果她忍不住破涕为笑，她生气这件事就算过去了。\n\n最重要的一点，一定要厚脸皮的，无休止的献殷勤，直到她开心或者和你说话为止。放心，你发过去她肯定会看到，女生往往都是在考验你或者说就是在等你一直发发发。\n\n补充一点，态度一定要诚恳，女人这件事她要的还是你一个态度，只要态度够诚恳够真心，能让她感受到的话，人家也肯定会原谅你的。\n\n最后一点就是事后一定要多沟通了，知道问题的关键所在(可能的话记下来)，下次才能尽量避免杜绝这样的事情发生，只要女友不生气，那咱不就剩哈哈哈了嘛。\n\n\n# 气之因 行之果\n\n男生一定主动一点\n\n女人都是口是心非，说你忙去吧不要真的去忙\n\n多找时间陪她\n\n两个人不要互相迁就，有什么一定要说\n\n每个女生都希望她是个小公主，希望你对她越来越好，是偏爱加独宠\n\n没事就一定一定一定要多找她多给她发消息",
      "normalizedContent": "# 伤脑\n\n女朋友生气了，而你毫无察觉。等到你看到女友那哀怨的小眼神，你才知道事情不妙，女朋友生气了。 问题的关键是，你觉得你压根就没有惹她。 故，今天，伤脑筋的是：女朋友生气了怎么办? 😱\n\n\n# 热狗之应\n\n女朋友生气的时候，或许你很莫名其妙，或许你很不理解，或许你还很心累很烦躁，但绝不要让自己的情绪被她更强烈的负面情绪带走。 或许她说话带刺，很难听，很伤人，也或许她的态度让人很不舒服，对你冷暴力，这时候万万不可动怒，一旦你也生气了，两人势必大吵一架，大吵之后若不能得到良好处理，就可能会产生感情隔阂，两人之间存在了不能触碰的禁区，显然会对日后分手埋下伏笔。\n\n所以你首先不能让自己产生情绪。\n\n发现女朋友生气了，首先你要理性地想，又来了，又耍小孩子脾气了，又要满嘴气话了，真拿这孩子没办法，好好哄吧。 没错，你要全程保持理性，跳出事件本身，清楚她说的难听的话都是气话，该想的是她为什么生气，这次该怎么哄，如何处理好她的这次生气。\n\n当然，如果真的很难忍，你还是爆炸了，那就尽兴大吵一架吧。不过等你冷静了，你还是得继续放下面子按以下步骤去哄。\n\n第一步 发现原因 对症下药 认真解释\n\n我怎么知道她为什么生气呢？ 这需要直男的你好好锻炼，日后慢慢get到你女朋友的生气点。 那最初小白的你怎么去了解呢？ 当然还得问她本人。\n\n如果你不是故意犯错，同时你真的直到实在不知道女朋友为什么生气，你完全可以拿出你最诚恳的态度去问。 必须是掏心肺腑的诚恳。 如果你单纯一句，宝贝，发生什么了，我到底哪儿做错了？ 可能只能得到一句反问，你居然不知道你哪儿错了？ 随后一句，你自己想，好好想想哪儿错了。 你只能原地懵逼百思不得解。\n\n拿出最诚恳的态度掏心肺腑地问应该是这样的。 宝贝，可能真的是我太笨太蠢了，我实在想不明白宝贝为什么生气，如果是因为我的问题，一定告诉我好吗，是我哪里考虑的太少，惹宝贝生气了？我总是很迟钝，一直不懂女孩子的心，可以给我一点点耐心吗？\n\n像这样把你真实心理过程掏心肺腑给她说，尽可能多地说，让她相信你是真不知道，你真是钢铁直男，那就没办法了只好告诉你了。\n\n知道了原因后必须对症下药，解释清楚。 为什么错了，为什么发生了，起因经过结尾，以及自己的全部心理过程。 没错这又是一个掏心肺腑的过程，要把自己的所有心里想法全透明给她。 当时怎么想的，之后怎么想的，为什么会发生这样的事，具体到每个细节，原原本本地说清楚。 如果你是冤枉的，就务必这样解释清楚，如果你真的有错，讲清情况后要立刻承认错误。 如果你的女朋友也很理性，能明事理，这样解释应该就可以解决问题。 但大多数不能，会认死理，要面子等等，那就要进行下一步。\n\n第二步 深情吐露心声\n\n这个标题感觉好违和。 先听我慢慢说吧。\n\n解释清楚后，就不要再拘泥于她生气的原因了，别揪着一个点再翻来覆去解释，只会越解释她越烦。\n\n在明了过程后，如果她还生气，可能是以下三个原因，一原因已经发生变化，比如你之后的态度不好之类，二可能是认死理，不行你犯了错咱俩就不能好了，三可能是爱面子，不行这事没完你得哄我。 无论哪种情况这时候都该进入哄的正题了。\n\n深情告白嘛就是再掏心肺腑地表达你有么多爱她，你有么多在乎她，你有多么重视她，这绝对是每个女孩子最想听的。\n\n直男不会花言巧语，就该掏心肺腑，而且女生相比花言巧语，更喜欢真实想法。就类似之前解释原因一样，你把重视她在乎她的心理过程再加进去，表达出你其实一直都是在想着她考虑着她，只是有时候方式方法出现了问题，你以后不会这样了。\n\n当然你可以跳出这件事，举例一些别的事，或者不具体到事，让她知道在你心里她多么重要，让她知道她的情绪总在影响着你的情绪，让她知道她开心你也开心，她不开心你也不开心，希望你可以让她总是有好心情，而不像这样因为自己而不高兴，让她知道她对你来说多么多么重要。 这里说的别俗套，把自己的真实想法说清楚就好。\n\n你爱他的时候，每个发自心底的想法都可以是好听的情话，即使表达拙劣一点，也会很感人。\n\n第三步 厚脸皮地哄她开心\n\n有时候，你深情太多，会显得自己很卑微，像个小丑一样在求她，这种时候不仅你自己会产生负面情绪，她也会有，会让她心里烦躁，感到有负担。你继续掏心肺腑反倒会换来她的不舒服，感觉跟你在一起是对你多大的亏欠。 所以你要及时切换心情，变成一个坏坏的，厚脸皮的，或者霸道的男友形象。 这时候必须已经过了她的气头，而在她单纯耍脾气求哄阶段。 怎么操作呢，夸她，各种夸张各种不要脸地夸，说难听点，就像卖国求荣的汉奸在讨好小日本。 然后就是说自己的不是，说自己蠢说自己笨，求包容求原谅。 然后再不停夸她，啊呀老婆最美最贤惠最善良天下第一好，得此良妻犹有何憾？ 啊呀宝贝最乖最可爱。 以后保证好好听你的。 乖，别闹了，听话。 你是我的，别想跑。 诸如此类。\n\n有时候哄女朋友不是你要哄到什么点哄到什么程度的问题，而是你要积累哄的时间，拿出你认真哄的态度给她看，这也是证明你多重视她的过程。\n\n第四步 事后沟通总结 我一直觉得情侣之间无论如何沟通最重要，尤其是异地恋。 包括之前说的，一旦你也爆炸了两人大吵一架，事后冷静了哄好后必须沟通好，必须针对此事好好谈谈交换想法，修补可能存在的裂缝。\n\n包括她生气了你单方面哄（她依然会觉得这是你们两人在吵架），哄完了你们也需要沟通，说说你们关于这件事的真实想法，说说两人以后怎么做。 遇到问题必须解决。\n\n当然，有些话你还是不敢对她说。 我替你说。\n\n哄女朋友确实是男朋友应该有的技能，尤其是异地恋，更容易缺乏安全感，再加上看着别的情侣秀恩爱，女孩子会更加觉得缺爱，所以会生气烦躁闹脾气很正常。\n\n可是啊，真的不要太作，一次两次或许可以接受，隔三差五的来，真的受不了，说不好听的，男朋友再好，再爱你，再温柔，迟早有一天也会给作没了。\n\n有的男生很直，很幼稚，很自私，但他们会为了女朋友在努力改变。 女生也会幼稚，也会自私，所以会作，会整天揪着他到底爱不爱我，有多在乎我，是不是没当初那么重视我了，然后以此去为难男朋友。\n\n即使像上述生气到哄的过程，也会耗费两人尤其是男生许多时间精力，这样的情况多了必然会影响到正常的生活。 两个人应该多些平等，多些理解，多些沟通，都该因为在一起而有所成长。\n\n\n# 最后的总结\n\n不管女朋友心情不好，无理取闹，还是你做错了事，你只要记住第一件事“你错了”。男人嘛，要大度一点。她很在意你此时的态度，如果你不理她或者一走了之，那我很悲伤地告诉你，你倒霉了。\n\n讲笑话，扮鬼脸，怎么搞笑怎么来，如果她忍不住破涕为笑，她生气这件事就算过去了。\n\n最重要的一点，一定要厚脸皮的，无休止的献殷勤，直到她开心或者和你说话为止。放心，你发过去她肯定会看到，女生往往都是在考验你或者说就是在等你一直发发发。\n\n补充一点，态度一定要诚恳，女人这件事她要的还是你一个态度，只要态度够诚恳够真心，能让她感受到的话，人家也肯定会原谅你的。\n\n最后一点就是事后一定要多沟通了，知道问题的关键所在(可能的话记下来)，下次才能尽量避免杜绝这样的事情发生，只要女友不生气，那咱不就剩哈哈哈了嘛。\n\n\n# 气之因 行之果\n\n男生一定主动一点\n\n女人都是口是心非，说你忙去吧不要真的去忙\n\n多找时间陪她\n\n两个人不要互相迁就，有什么一定要说\n\n每个女生都希望她是个小公主，希望你对她越来越好，是偏爱加独宠\n\n没事就一定一定一定要多找她多给她发消息",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "此一去不过经年，再回首不复往昔",
      "frontmatter": {
        "title": "此一去不过经年，再回首不复往昔",
        "date": "2018-11-09T15:54:56.000Z",
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "sticky": 1,
        "isShowComments": true
      },
      "regularPath": "/views/essay/20191109.html",
      "relativePath": "views/essay/20191109.md",
      "key": "v-00ac03aa",
      "path": "/views/essay/20191109.html",
      "headers": [
        {
          "level": 2,
          "title": "浪费的时间",
          "slug": "浪费的时间",
          "normalizedTitle": "浪费的时间",
          "charIndex": 38
        },
        {
          "level": 2,
          "title": "学习",
          "slug": "学习",
          "normalizedTitle": "学习",
          "charIndex": 709
        },
        {
          "level": 2,
          "title": "我这是怎么了",
          "slug": "我这是怎么了",
          "normalizedTitle": "我这是怎么了",
          "charIndex": 1231
        }
      ],
      "excerpt": "<Boxx/>\n<p>不知道怎么开头，就是想写点东西，然后记录一下自己，嗯，就这么简单。</p>\n",
      "headersStr": "浪费的时间 学习 我这是怎么了",
      "content": "不知道怎么开头，就是想写点东西，然后记录一下自己，嗯，就这么简单。\n\n\n# 浪费的时间\n\n不知不觉北京深秋已过，渐入初冬了。而我自工作以来，似乎是适应了北京的这种快节奏和生活。\n\n上班，下班，吃饭，睡觉，单位宿舍两点一线，属于自己的时间很少，不对，不是很少，只不过是都用来做无用功了，无意义的加班、游戏以及挤地铁。\n\n每个人都生活在自己的舒适区，一旦我们适应了这种生活就很难做出改变，同样，也就很难成长。\n\n而我已不自觉的掉了进去，当然，更多的还是自己对时间概念认识的不足。\n\n前几天看到时间管理中与“墨菲定律”、“彼得原理”同样有趣的定律是“帕金森定理”，第一次看到“帕金森”这个词，我不禁想到了一代传奇人物尼古拉斯赵四，哈哈，赵四跳舞，大个儿说：没有精神病还真跳不出这帕金森的感觉！\n\n帕金森定理按我的理解通俗来讲：就是不管给你的一项工作分配多少时间，这项工作总会膨胀使用完这段时间。\n\n举个例子，就好比当时上大学的时候，老师布置的作业，不管给你三天、五天、一个月，但在这段时间内，我们总是会找各种借口去拖延，去占用这段时间，在完成作业或任务的时候往往是最后那几天。\n\n无奈吧，但这就是拖延的后果，令人沮丧。\n\n同时也通俗的介绍一下墨菲定律和彼得原理吧：\n\n * 墨菲定律：越害怕（担心）什么，就越会发生什么。\n * 彼得原理：一个人的能力和要提升的职位不相匹配，从公司角度出发短期内可能看不出来有什么不好的地方，但长远来看，会对公司对组织的长远发展造成不利影响。\n\n所以，我给自己总结一招就是：简单的事情简单做，复杂的事情简单做。手机上也下载了ToDo，就像微软介绍的那样，就从“我的一天”开始吧。\n\n\n\n\n# 学习\n\n前端时间一直在搞自己的博客，从之前的hexo迁到了新兴的vuepress，从而认识了vuepress-theme-reco这里的好多小伙伴。\n\n有幸，我的博客被当做“Nice Blog Examples”被展示在了官网上供其他人交流和参考。\n\n\n\n话说回来，除了做博客之外，这段时间也真的学了不少，Vue、JWT、Mq、Redis、SpringBoot、SpringCloud，且不说工作中有没有用到，但奈何都只是皮毛，更何况学的多又杂，很多的知识层面都只是停留在基础上或者会用上，更多的原理、底层都还需要挖掘。\n\n虽然大部分知识都过了一遍，但脑子里还没形成自己的架构，这就真的是没有学透。\n\n好比Vue，之前跟着教程学了一遍敲了个项目在github上，也有十几个人start了，但前段时间有人问我问题的时候，内心动态是这样的：“我去，什么鬼，当时为什么这样写？”，事情往往就是这样，刚学完的时候感觉，嗯，也还可以，但时间长不接触或者不看之后，真的是会忘的。\n\n怎么说呢，知识这种东西，学过一遍和没学过是不一样的，我可能忘了它，但我的骨子里已经有了它。\n\n希望它没有忘记我吧！\n\n只能找个时间再学一遍了，来，ToDo，安排上！\n\n\n# 我这是怎么了\n\n每隔一段时间，就忍不住想写写东西，明明心里有话但就是敲不出来。\n\n定个目标：每月抽些时间，随笔也好，记录也罢，总得要拿些东西出来的呀！\n\n可能对于那些“不存在读者”来说，这些文字就是一些乱七八糟的鸡汤，但对我来说，是对我过去的一些记录也是对我之后的一点鼓励。\n\n搞了一个小时就这样吧！2333",
      "normalizedContent": "不知道怎么开头，就是想写点东西，然后记录一下自己，嗯，就这么简单。\n\n\n# 浪费的时间\n\n不知不觉北京深秋已过，渐入初冬了。而我自工作以来，似乎是适应了北京的这种快节奏和生活。\n\n上班，下班，吃饭，睡觉，单位宿舍两点一线，属于自己的时间很少，不对，不是很少，只不过是都用来做无用功了，无意义的加班、游戏以及挤地铁。\n\n每个人都生活在自己的舒适区，一旦我们适应了这种生活就很难做出改变，同样，也就很难成长。\n\n而我已不自觉的掉了进去，当然，更多的还是自己对时间概念认识的不足。\n\n前几天看到时间管理中与“墨菲定律”、“彼得原理”同样有趣的定律是“帕金森定理”，第一次看到“帕金森”这个词，我不禁想到了一代传奇人物尼古拉斯赵四，哈哈，赵四跳舞，大个儿说：没有精神病还真跳不出这帕金森的感觉！\n\n帕金森定理按我的理解通俗来讲：就是不管给你的一项工作分配多少时间，这项工作总会膨胀使用完这段时间。\n\n举个例子，就好比当时上大学的时候，老师布置的作业，不管给你三天、五天、一个月，但在这段时间内，我们总是会找各种借口去拖延，去占用这段时间，在完成作业或任务的时候往往是最后那几天。\n\n无奈吧，但这就是拖延的后果，令人沮丧。\n\n同时也通俗的介绍一下墨菲定律和彼得原理吧：\n\n * 墨菲定律：越害怕（担心）什么，就越会发生什么。\n * 彼得原理：一个人的能力和要提升的职位不相匹配，从公司角度出发短期内可能看不出来有什么不好的地方，但长远来看，会对公司对组织的长远发展造成不利影响。\n\n所以，我给自己总结一招就是：简单的事情简单做，复杂的事情简单做。手机上也下载了todo，就像微软介绍的那样，就从“我的一天”开始吧。\n\n\n\n\n# 学习\n\n前端时间一直在搞自己的博客，从之前的hexo迁到了新兴的vuepress，从而认识了vuepress-theme-reco这里的好多小伙伴。\n\n有幸，我的博客被当做“nice blog examples”被展示在了官网上供其他人交流和参考。\n\n\n\n话说回来，除了做博客之外，这段时间也真的学了不少，vue、jwt、mq、redis、springboot、springcloud，且不说工作中有没有用到，但奈何都只是皮毛，更何况学的多又杂，很多的知识层面都只是停留在基础上或者会用上，更多的原理、底层都还需要挖掘。\n\n虽然大部分知识都过了一遍，但脑子里还没形成自己的架构，这就真的是没有学透。\n\n好比vue，之前跟着教程学了一遍敲了个项目在github上，也有十几个人start了，但前段时间有人问我问题的时候，内心动态是这样的：“我去，什么鬼，当时为什么这样写？”，事情往往就是这样，刚学完的时候感觉，嗯，也还可以，但时间长不接触或者不看之后，真的是会忘的。\n\n怎么说呢，知识这种东西，学过一遍和没学过是不一样的，我可能忘了它，但我的骨子里已经有了它。\n\n希望它没有忘记我吧！\n\n只能找个时间再学一遍了，来，todo，安排上！\n\n\n# 我这是怎么了\n\n每隔一段时间，就忍不住想写写东西，明明心里有话但就是敲不出来。\n\n定个目标：每月抽些时间，随笔也好，记录也罢，总得要拿些东西出来的呀！\n\n可能对于那些“不存在读者”来说，这些文字就是一些乱七八糟的鸡汤，但对我来说，是对我过去的一些记录也是对我之后的一点鼓励。\n\n搞了一个小时就这样吧！2333",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "人逐渐成熟的过程往往也是心逐渐麻木的过程",
      "frontmatter": {
        "title": "人逐渐成熟的过程往往也是心逐渐麻木的过程",
        "date": "2020-07-03T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20200703.html",
      "relativePath": "views/essay/20200703.md",
      "key": "v-82904d06",
      "path": "/views/essay/20200703.html",
      "headers": [
        {
          "level": 2,
          "title": "始",
          "slug": "始",
          "normalizedTitle": "始",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "感",
          "slug": "感",
          "normalizedTitle": "感",
          "charIndex": 167
        },
        {
          "level": 2,
          "title": "奈",
          "slug": "奈",
          "normalizedTitle": "奈",
          "charIndex": 515
        }
      ],
      "headersStr": "始 感 奈",
      "content": "# 始\n\n\n\n前阵子在豆瓣上看到一个帖子，提问是：“你的工资能满足你体面的生活吗？”\n\n底下评论的人很多，其中最让人深刻的是这三条：\n\n 1. “四线城市，公务员，两个月的工资勉强够一个月的开销。”\n\n 2. “两万左右，在北京，不买房子的话，活得还行，就是要出卖自己的健康。”\n\n 3. “税后一万二，在广州，偶尔得出卖自己的灵魂，感觉前途一片灰暗，唯一值得庆幸的是不靠家里…”\n\n\n# 感\n\n看完这个帖子我突然觉得有些凄凉，按理说这是最好的时代，你头上明明顶着21世纪的太阳，但是抬头看，依然有阴霾；你明明生长在一个蓬勃发展的时代，但是你心里依然充满不安。\n\n更可怕的是，你的身体就像一块劣质的电池，充电需要充很久，不但充不满而且用得快。你看起来很忙，忙得根本停不下来。可你实际上又很穷，穷得不敢停下来。至于体面地生活，遥远得像是下辈子的事儿。\n\n你学会了说：“谈钱伤感情”，可后来才发现，没钱才伤感情。\n\n你学会了说：“要保持独立的人格，不被金钱左右”，可后来才发现，没钱的灵魂根本就没法硬气地站立。\n\n你学会了说：“要孝敬父母、让在乎的人过上幸福的日子”，可后才发现，没钱根本就做不了孝子，也给不了在乎的人幸福。\n\n\n# 奈\n\n看，你学了多少年的对错，可现如今才明白，现实只讲输赢。",
      "normalizedContent": "# 始\n\n\n\n前阵子在豆瓣上看到一个帖子，提问是：“你的工资能满足你体面的生活吗？”\n\n底下评论的人很多，其中最让人深刻的是这三条：\n\n 1. “四线城市，公务员，两个月的工资勉强够一个月的开销。”\n\n 2. “两万左右，在北京，不买房子的话，活得还行，就是要出卖自己的健康。”\n\n 3. “税后一万二，在广州，偶尔得出卖自己的灵魂，感觉前途一片灰暗，唯一值得庆幸的是不靠家里…”\n\n\n# 感\n\n看完这个帖子我突然觉得有些凄凉，按理说这是最好的时代，你头上明明顶着21世纪的太阳，但是抬头看，依然有阴霾；你明明生长在一个蓬勃发展的时代，但是你心里依然充满不安。\n\n更可怕的是，你的身体就像一块劣质的电池，充电需要充很久，不但充不满而且用得快。你看起来很忙，忙得根本停不下来。可你实际上又很穷，穷得不敢停下来。至于体面地生活，遥远得像是下辈子的事儿。\n\n你学会了说：“谈钱伤感情”，可后来才发现，没钱才伤感情。\n\n你学会了说：“要保持独立的人格，不被金钱左右”，可后来才发现，没钱的灵魂根本就没法硬气地站立。\n\n你学会了说：“要孝敬父母、让在乎的人过上幸福的日子”，可后才发现，没钱根本就做不了孝子，也给不了在乎的人幸福。\n\n\n# 奈\n\n看，你学了多少年的对错，可现如今才明白，现实只讲输赢。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "平海漫漫惜别离",
      "frontmatter": {
        "title": "平海漫漫惜别离",
        "date": "2020-07-15T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true,
        "author": "zhangpengjun,liuhongliang"
      },
      "regularPath": "/views/essay/20200715.html",
      "relativePath": "views/essay/20200715.md",
      "key": "v-0d49e57b",
      "path": "/views/essay/20200715.html",
      "headers": [
        {
          "level": 2,
          "title": "近况",
          "slug": "近况",
          "normalizedTitle": "近况",
          "charIndex": 33
        },
        {
          "level": 2,
          "title": "唏嘘",
          "slug": "唏嘘",
          "normalizedTitle": "唏嘘",
          "charIndex": 163
        },
        {
          "level": 2,
          "title": "成熟",
          "slug": "成熟",
          "normalizedTitle": "成熟",
          "charIndex": 7
        }
      ],
      "excerpt": "<Boxx/>\n<p>人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。</p>\n",
      "headersStr": "近况 唏嘘 成熟",
      "content": "人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。\n\n\n# 近况\n\n许久不见，疫情影响，近来居家隔离中。\n\n短短几天，都不晓得外面世界的样子了，真想一下打破这股子宁静，出去狂吸几口子那干净而又充满了夏季香草味的雨后空气。\n\n奈。。\n\n人在家中坐，心游身不由，只能体验下 刘禹锡 的 “斯是陋室，惟吾德馨” 了。\n\n\n# 唏嘘\n\n这不，只剩无情的工作外加挚友聊天，又外加近期博文没更。\n\n故，社会你亮哥把珍藏多年的金句给了我才有了这篇合作，心想存下金句的同时也为友情留个纪念，如若下次相遇或待年老之后，也为吹嘘打闹作一番唏嘘😄，注意哈，云瀚语录要开始了：\n\n * 因为有你, 让我变成更优秀的自己\n\n * 我明白你的意思，你我之间不需要解释\n\n * 你许我一时温柔，我还你一个春秋\n\n * 柜子里的衣服在不断更迭，身边的朋友何尝不是\n\n * 生活已经让他们失望很多次了，不差这一次\n\n * 不做无谓之争，输了你赢了世界又如何\n\n * 苟且的生活中也有诗与远方\n\n * 没有希望就没有失望，普通的生活才是常态\n\n * 努力学习一项技能或许不能马上变现，但它却是你一辈子的财富\n\n * 地点还是那个地点，人群却不是那个人群了\n\n * 有些人虽然说了再见，却有可能再也不见了\n\n * 我又不喜欢你，凭什么要求我渣你\n\n * 我们一直拥有的，原本是自己早已拥有的\n\n * 曾经心塞的地方，如今向往的地方\n\n * 别傻了，生活是自己的，不是给别人看的\n\n * 知世故而不世故，愿你保持善良，一如既往\n\n * 何必极力追求终点，路上亦是风景\n\n * 不念过去，不畏将来，珍惜当下，好好生活\n\n * 幸福其实很简单，此处省略无数个字\n\n * 看这人群熙熙攘攘，却不知自己该去向何方\n\n * 如果你不够优秀，人脉是不值钱的，它不是追求来的，而是吸引来的。只有等价的交换，才能得到合理的帮助，虽然听起来很冷，但这是事实\n\n * 你看着别人遥不可及的技能，可能是别人生存的本能\n\n * 生活就像咖啡只有细品才能尝到苦中的甜\n\n * 不是它不够好，是你欣赏不了\n\n * 希望你能时刻感受到生活的美好，不留遗憾\n\n * 学最好的别人，做最好的自己\n\n夏季\n\n友情\n\n- img: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  link: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  name: 夏季\n- img: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  link: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  name: 友情\n\n\n1\n2\n3\n4\n5\n6\n\n\n寥寥几句，我相信每一句的背后肯定都是一个故事，记录着成长路上的点滴。\n\n\n# 成熟\n\n你看，其实每个人都有自己的成长感悟，可能是只言片句，可能是散水流文，也可能是心语言不语。\n\n人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。越成熟越发现，成年人的发泄方式，不再是改头像、换签名、发朋友圈，而是吹吹风，静一静，习惯性的等待自愈！\n\n生活离我们越来越近，朋友之间的联系不再那么频繁，恋人又即将占据我们的全部，愿兄弟们都能找到心满意足的生活，在这个繁杂的社会上，简单、快乐就好！\n\n还有啊，还有虽然平时不怎么联系，但偶尔会给你打个电话问候一下的朋友，真的，很幸运能在人生的路上遇到你们，亮，雷，坤，伟，大军，我想你们拉~~",
      "normalizedContent": "人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。\n\n\n# 近况\n\n许久不见，疫情影响，近来居家隔离中。\n\n短短几天，都不晓得外面世界的样子了，真想一下打破这股子宁静，出去狂吸几口子那干净而又充满了夏季香草味的雨后空气。\n\n奈。。\n\n人在家中坐，心游身不由，只能体验下 刘禹锡 的 “斯是陋室，惟吾德馨” 了。\n\n\n# 唏嘘\n\n这不，只剩无情的工作外加挚友聊天，又外加近期博文没更。\n\n故，社会你亮哥把珍藏多年的金句给了我才有了这篇合作，心想存下金句的同时也为友情留个纪念，如若下次相遇或待年老之后，也为吹嘘打闹作一番唏嘘😄，注意哈，云瀚语录要开始了：\n\n * 因为有你, 让我变成更优秀的自己\n\n * 我明白你的意思，你我之间不需要解释\n\n * 你许我一时温柔，我还你一个春秋\n\n * 柜子里的衣服在不断更迭，身边的朋友何尝不是\n\n * 生活已经让他们失望很多次了，不差这一次\n\n * 不做无谓之争，输了你赢了世界又如何\n\n * 苟且的生活中也有诗与远方\n\n * 没有希望就没有失望，普通的生活才是常态\n\n * 努力学习一项技能或许不能马上变现，但它却是你一辈子的财富\n\n * 地点还是那个地点，人群却不是那个人群了\n\n * 有些人虽然说了再见，却有可能再也不见了\n\n * 我又不喜欢你，凭什么要求我渣你\n\n * 我们一直拥有的，原本是自己早已拥有的\n\n * 曾经心塞的地方，如今向往的地方\n\n * 别傻了，生活是自己的，不是给别人看的\n\n * 知世故而不世故，愿你保持善良，一如既往\n\n * 何必极力追求终点，路上亦是风景\n\n * 不念过去，不畏将来，珍惜当下，好好生活\n\n * 幸福其实很简单，此处省略无数个字\n\n * 看这人群熙熙攘攘，却不知自己该去向何方\n\n * 如果你不够优秀，人脉是不值钱的，它不是追求来的，而是吸引来的。只有等价的交换，才能得到合理的帮助，虽然听起来很冷，但这是事实\n\n * 你看着别人遥不可及的技能，可能是别人生存的本能\n\n * 生活就像咖啡只有细品才能尝到苦中的甜\n\n * 不是它不够好，是你欣赏不了\n\n * 希望你能时刻感受到生活的美好，不留遗憾\n\n * 学最好的别人，做最好的自己\n\n夏季\n\n友情\n\n- img: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  link: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  name: 夏季\n- img: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  link: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  name: 友情\n\n\n1\n2\n3\n4\n5\n6\n\n\n寥寥几句，我相信每一句的背后肯定都是一个故事，记录着成长路上的点滴。\n\n\n# 成熟\n\n你看，其实每个人都有自己的成长感悟，可能是只言片句，可能是散水流文，也可能是心语言不语。\n\n人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。越成熟越发现，成年人的发泄方式，不再是改头像、换签名、发朋友圈，而是吹吹风，静一静，习惯性的等待自愈！\n\n生活离我们越来越近，朋友之间的联系不再那么频繁，恋人又即将占据我们的全部，愿兄弟们都能找到心满意足的生活，在这个繁杂的社会上，简单、快乐就好！\n\n还有啊，还有虽然平时不怎么联系，但偶尔会给你打个电话问候一下的朋友，真的，很幸运能在人生的路上遇到你们，亮，雷，坤，伟，大军，我想你们拉~~",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "好歌 200813 - 旅行",
      "frontmatter": {
        "title": "好歌 200813 - 旅行",
        "date": "2020-08-13T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20200813.html",
      "relativePath": "views/essay/20200813.md",
      "key": "v-0ecf6c86",
      "path": "/views/essay/20200813.html",
      "headers": [
        {
          "level": 3,
          "title": "云热评：",
          "slug": "云热评",
          "normalizedTitle": "云热评：",
          "charIndex": 480
        }
      ],
      "excerpt": "<Boxx/>\n<p>这首歌是许巍为了纪念 2004 年初因车祸逝世的青岛朋友丁志强创作的 ，事实上这是一首很早就录音完成的歌，却是最后才有名字的 。</p>\n",
      "headersStr": "云热评：",
      "content": "这首歌是许巍为了纪念 2004 年初因车祸逝世的青岛朋友丁志强创作的 ，事实上这是一首很早就录音完成的歌，却是最后才有名字的 。\n\n借许巍老师的话来说，旅行是经历种种景色的地理意义上的跋涉，人生更是这样一场需要经历风雨的 “旅行” 。\n\n人生处处在旅行亦或修行，旅行的意义在于，它是一次成长的历练，强迫你独立生活，心智成长。\n\n旅行 - 许巍\n\n旅行 (《后会无期》电影插曲) - 许巍\n\n词：许巍\n曲：许巍\n编曲：许巍\n\n阵阵晚风吹动着松涛\n吹响这风铃声如天籁\n站在这城市的寂静处\n让一切喧嚣走远\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n\n# 云热评：\n\n黑龙江大庆：有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧\n\n2015 年 1 月 12 日\n\n趴着睡比较好：许巍的歌，不买个 SUV 在高速上面边听边开都算埋汰了啊～！！！！！！\n\n2014 年 12 月 28 日\n\n睦寰：变老的标志就是口味的改变，喜欢一些之前觉得土的东西，然后对生活麻木，过一天就一天。\n\n2014 年 11 月 26 日\n\n757351：去年我辞掉工作 八个月时间 16000 公里环骑游中国 我真不敢想像如果没有许巍这一路是怎么过来的 现在想想挺着他的歌陪着我走过高原 山区 平地 古镇 古迹 以及眼前看过的一切美景 真的感谢许巍\n\n2016 年 2 月 13 日\n\n为什么注册不上：上大学的时候有个新疆的同学，我们都问他，为什么跑这么远来西安上学，他说：西安有许巍，有郑钧，有城墙\n\n2015 年 10 月 9 日\n\n素颜嫣然：天亮是六点半到六点四十，十分钟之间。今天天空非常清亮，站在阳台能望得很远很远，甚至看见了天边久违的思念... 裹紧外套，煎荷包蛋叫孩子们吃饭！早安，今天！\n\n2014 年 12 月 4 日",
      "normalizedContent": "这首歌是许巍为了纪念 2004 年初因车祸逝世的青岛朋友丁志强创作的 ，事实上这是一首很早就录音完成的歌，却是最后才有名字的 。\n\n借许巍老师的话来说，旅行是经历种种景色的地理意义上的跋涉，人生更是这样一场需要经历风雨的 “旅行” 。\n\n人生处处在旅行亦或修行，旅行的意义在于，它是一次成长的历练，强迫你独立生活，心智成长。\n\n旅行 - 许巍\n\n旅行 (《后会无期》电影插曲) - 许巍\n\n词：许巍\n曲：许巍\n编曲：许巍\n\n阵阵晚风吹动着松涛\n吹响这风铃声如天籁\n站在这城市的寂静处\n让一切喧嚣走远\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n\n# 云热评：\n\n黑龙江大庆：有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧\n\n2015 年 1 月 12 日\n\n趴着睡比较好：许巍的歌，不买个 suv 在高速上面边听边开都算埋汰了啊～！！！！！！\n\n2014 年 12 月 28 日\n\n睦寰：变老的标志就是口味的改变，喜欢一些之前觉得土的东西，然后对生活麻木，过一天就一天。\n\n2014 年 11 月 26 日\n\n757351：去年我辞掉工作 八个月时间 16000 公里环骑游中国 我真不敢想像如果没有许巍这一路是怎么过来的 现在想想挺着他的歌陪着我走过高原 山区 平地 古镇 古迹 以及眼前看过的一切美景 真的感谢许巍\n\n2016 年 2 月 13 日\n\n为什么注册不上：上大学的时候有个新疆的同学，我们都问他，为什么跑这么远来西安上学，他说：西安有许巍，有郑钧，有城墙\n\n2015 年 10 月 9 日\n\n素颜嫣然：天亮是六点半到六点四十，十分钟之间。今天天空非常清亮，站在阳台能望得很远很远，甚至看见了天边久违的思念... 裹紧外套，煎荷包蛋叫孩子们吃饭！早安，今天！\n\n2014 年 12 月 4 日",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/22, 09:55:03",
      "lastUpdatedTimestamp": 1632275703000
    },
    {
      "title": "中台",
      "frontmatter": {
        "title": "中台",
        "date": "2021-12-16T00:00:00.000Z",
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20211216.html",
      "relativePath": "views/essay/20211216.md",
      "key": "v-ba4cab7a",
      "path": "/views/essay/20211216.html",
      "headers": [
        {
          "level": 2,
          "title": "中台由来",
          "slug": "中台由来",
          "normalizedTitle": "中台由来",
          "charIndex": 208
        },
        {
          "level": 2,
          "title": "聊聊架构",
          "slug": "聊聊架构",
          "normalizedTitle": "聊聊架构",
          "charIndex": 868
        },
        {
          "level": 2,
          "title": "单体架构的时代",
          "slug": "单体架构的时代",
          "normalizedTitle": "单体架构的时代",
          "charIndex": 910
        },
        {
          "level": 2,
          "title": "SOA(Service-Oriented Architecture)",
          "slug": "soa-service-oriented-architecture",
          "normalizedTitle": "soa(service-oriented architecture)",
          "charIndex": 1574
        },
        {
          "level": 2,
          "title": "微服务架构",
          "slug": "微服务架构",
          "normalizedTitle": "微服务架构",
          "charIndex": 2606
        },
        {
          "level": 2,
          "title": "服务共享",
          "slug": "服务共享",
          "normalizedTitle": "服务共享",
          "charIndex": 3068
        },
        {
          "level": 2,
          "title": "服务拆分",
          "slug": "服务拆分",
          "normalizedTitle": "服务拆分",
          "charIndex": 3583
        },
        {
          "level": 2,
          "title": "交易中台",
          "slug": "交易中台",
          "normalizedTitle": "交易中台",
          "charIndex": 108
        },
        {
          "level": 2,
          "title": "金融中台",
          "slug": "金融中台",
          "normalizedTitle": "金融中台",
          "charIndex": 113
        },
        {
          "level": 2,
          "title": "去中台化",
          "slug": "去中台化",
          "normalizedTitle": "去中台化",
          "charIndex": 6036
        }
      ],
      "excerpt": "<Boxx/>\n<p>今天给大家分享一下关于架构和中台的一些东西。</p>\n<p>主要会介绍一下中台的来源，这个大家可能都比较清楚，网上的文章和视频啊一大堆。</p>\n<p>还有就是关于架构的发展过程不得不在中间说明一下，由此引申出来中台的诞生。</p>\n<p>最后会就关于交易中台和金融中台做一个介绍，因为我最近两年在其他公司做的一个是交易中台，还有一个就是金融中台相关的业务。</p>\n",
      "headersStr": "中台由来 聊聊架构 单体架构的时代 SOA(Service-Oriented Architecture) 微服务架构 服务共享 服务拆分 交易中台 金融中台 去中台化",
      "content": "今天给大家分享一下关于架构和中台的一些东西。\n\n主要会介绍一下中台的来源，这个大家可能都比较清楚，网上的文章和视频啊一大堆。\n\n还有就是关于架构的发展过程不得不在中间说明一下，由此引申出来中台的诞生。\n\n最后会就关于交易中台和金融中台做一个介绍，因为我最近两年在其他公司做的一个是交易中台，还有一个就是金融中台相关的业务。\n\n> 公司内做的一个简单的分享，文章内容是我根据自己讲的还有录像又手撸了一遍，累。\n\n\n# 中台由来\n\n首先，来看一下中台的由来。\n\n中台的来源主要是阿里，他们在15年拜访在芬兰的一家游戏公司，也就是SuperCell。\n\n这家公司非常牛逼，号称是世界上最成功的的移动游戏公司，做出的游戏也非常有名，肯定很多人也玩过。\n\n比如部落战争、海岛奇兵等等。\n\n我也玩过一下他们的那个游戏，不过觉得没啥意思。\n\n这家公司的规模只有不到200人，公司的开发模式通常都会由2-7个人的小团队进行开发，这个在他们内部叫做cell，这也是他们公司名字的由来。\n\n开发过程通常是团队内部决定，然后用最快的时间开发出测试版本，如果受欢迎就继续干，否则的话就迅速放弃。\n\n产品失败之后，不光不会受到惩罚，他们还会搞个party来庆祝，庆祝自己学到了新的东西。\n\n不过我觉得挺奇葩的，要是都按照他们这个模式来，早期腾讯、阿里这些大公司都该死绝了。\n\n我们都知道，腾讯早期的时候想卖100万都没人要，马总实在没辙才只能硬着头皮继续做下去。\n\n但是，就是这样一家小公司，2015年的净利润达到了15亿美元，而且在2016年的时候被腾讯86亿美元收购。\n\n这些都不是重点哈，重点我们今天要讲的是他们的开发模式，为什么能快速开发一个新游戏出来？\n\n本来在我们想象中，开发一个新的游戏是一个很耗费时间精力的东西，几周开发一个还不错的游戏应该是很有难度的事情。\n\n重点就在于他们的”中台“，也是他们多年游戏沉淀下来的东西。\n\n他们在前面的很多年时间里对通用的游戏素材、算法等等做了很多沉淀。\n\n这也就是后面马云回来阿里之后大力搞的中台了。\n\n\n# 聊聊架构\n\n讲完中台的来历，在将中台之前，我们还是要先说说架构的发展过程。\n\n\n# 单体架构的时代\n\n在我刚刚上班的时候，大概是11年、12年基本上我接触到的项目都是这个样子。\n\n一个团队的所有东西都在一块，什么用户注册登录、支付啊、订单都在一起，经常是改一个小东西一个大项目都要跟着发布。\n\n一般单体的架构都是单进程的，这也是针对我们现在的微服务来说的，就是打个jar包或者war包上传就完事儿了，所有模块都在一个进程里，如果要升级或者重启，那整个应用服务都要重启。\n\n当然了，简单的项目划分模块分层还是有的，比如我们那时候常用的MVC模式。\n\n\n\n简单是很简单，但是同样缺点也是很明显的。\n\n第一点就是团队协同合作的成本高，如果说小公司没几个人还好，一旦业务快速发展起来，代码量感人，刚开始上班那会儿我的电脑经常就只能跑的动一个项目，不过好像也没有别的项目了。\n\n经常改一个简单的东西可能到处是冲突，更不要说一个大服务的发版问题。\n\n第二点，项目太复杂了，什么东西都是大杂烩，全在里面。\n\n第三点，数据库连接的问题，一个服务太大了，就一个数据库的集群，业务越来越多，服务器越来越多，到后面单机可能只搞个个位数的连接都要不够用了。\n\n所以，一般伴随拆分服务，数据库也会做拆分，独立的服务拥有独立的数据库。\n\n最后一点，拓展性的问题，所有的功能都在一个服务里，可能实际情况是某几个功能模块负载非常高，比如订单或者库存的服务，频繁的读写，这时候想要扩展很难搞。\n\n更严重的问题就是，如果一个模块出了问题，整个应用都不能用了。\n\n这时候没有办法了，只能拆分。\n\n因此就到了我们第二个架构模式，SOA的时代。\n\n\n# SOA(Service-Oriented Architecture)\n\n我在饿了么工作那会儿，里面就有一大堆的SOA的称呼，并且一直都是。\n\nSOA是什么意思呢，全名是这个Service-Oriented Architecture，意思就是面向服务的架构，基本上和我们现在的微服务差不多一样。\n\nSOA的核心在于：松耦合和服务重用，当单体架构出现瓶颈的时候，首先想到的都是拆，SOA时代的话，其实也已经就有了服务注册发现、服务治理这些概念了，和微服务可以说从认知上没有任何区别。\n\nSOA其实有两种模式，一种是中心化，一种是去中心化，下图中表示的就是中心化的服务调用方式。\n\n\n\n服务调用之间都通过ESB服务总线，调用方之间屏蔽了接口的修改，ESB要做服务请求路由、数据格式转换，各种HTTP SOCKET适配和接入，所有脏活累活都归他干了。\n\n这样很明显的看出来问题了。\n\n第一个就是请求，同样的请求次数是通常去中心化的2倍，本来A调用B，现在要通过ESB。\n\n第二个是肉眼可见的问题，这个ESB的压力会非常大，可以通过集群解决，但是ESB的性能瓶颈会导致所有服务的瓶颈。\n\n但是，这个模式在当初非常受欢迎，主要原因是什么呢？\n\n就是烟囱式架构引发出来的问题。\n\n烟囱式架构是什么？\n\n\n\n就像这张图描述的，你有好几个业务，因为时间或者说团队、公司各种原因，搞成了好几套独立的服务，开发和运维都没啥关系，大多数公司之前的发展过程中都会存在这样的问题。\n\n比如我之前的公司先做酒店业务、然后又有外卖、还有餐饮店、还要卖咖啡。\n\n如果说来一个业务就重头搞一套用户体系、订单体系、库存体系，最终的结果就是像矗立起来的一个个烟囱，也就是烟囱式架构。\n\n烟囱的现象很普遍，大家各玩各的，先把业务跑起来再说，但是缺陷有很多。\n\n首先，重复建设开发，不用说都能看出来，每次重头搞一套，不说开发成本，就说服务器和运维成本都够头疼的。\n\n第二点，就是系统之间交互协作成本直线上升，业务发展了，可能要做一些精确营销活动，设计用户画像，对数据分析之类的啦，这都很正常。\n\n哦豁，这时候你发现用户在好几个系统里，这个交互打通的成本就太高了。\n\n要做个数据统计，还要调好几个系统接口，可能数据结构还不一样，搞都搞死你。\n\n还有就是业务沉淀和发展，这也是后面要说的中台了。\n\n难道这些系统之间就没有通用的能抽象的能力可以共用吗？\n\n这也就是中台的发展的方向，抽象、沉淀和共用。\n\n\n\n\n# 微服务架构\n\n最后就是说到我们的微服务时代了，这个大家都很熟悉，不需要说太多东西。\n\n至于现在还有Serverless、云原生什么低代码这里就不展开了，等后面的话有机会再说。\n\n回到微服务的话题，微服务和SOA有什么区别。\n\n个人认为其实很接近，微服务就是更加自由和更细粒度的SOA。\n\n微服务没有那么多框架约束，我们想用啥用啥，虽然在SOA也可以实现，比如通信我们可以用Dubbo，可以用Feign，Thrift，GRPC，想用啥用啥。\n\n举个例子用 spring cloud 来说，eureka可以帮我们做服务注册和发现，打个@enableEurekaClient就可以成为客户端连接到Eureka了。\n\n路由直接用zuul，限流熔断用hystrix，负载均衡用ribbon，远程调用用feign。\n\n非常方便，当然还可以选择用Spring Cloud Alibaba，这个我认为可能会是将来一段时间的趋势，更新维护的非常勤快。\n\nDubbo Nacos Sentinel这一套整起来明显更符合国内的使用习惯。\n\n\n# 服务共享\n\n说完架构的发展，可以回到我们之前的中台话题。\n\n那其实中台的作用已经不言而喻了，就是共享。\n\n以现在比较主流的一些电商来说，几个共享服务中心的划分。\n\n\n\n首先用户中心必不可少，用户是基础服务，用户中心集成用户通用的能力，包括注册登录，SSO单点登录，还要和大数据配合用户打标签，用户画像等。\n\n营销中心这个也很重要，包含各种优惠活动、优惠券、红包、卡券、积分、会员等级、返佣之类的和营销相关的东西。\n\n交易中心处理用户下订单，如果下单有返佣，积分之类的话，这个叫做履约，后面再说，关于交易中台是我后面要说的。\n\n支付中心负责支付，退款，三方支付、银行对接、预算管控等等。\n\n数据中心，这个其实和业务中台是两块方向，今天我要说的都是业务中台，针对业务系统的沉淀和共享，数据中台则是更偏向大数据方向的，不在这里赘述。\n\n最底层服务是我们的基础设施和中间件的能力，比如数据库、消息服务Kafka、Rabbitmq、数仓、文件系统。\n\n这张图画出来好像除了中台和前台没别的东西了，并不是这样，我只是想表达说共享服务是作为支撑上层业务的核心，下层还有后台的服务并没有画出来而已，也就是顺应着大中台、小前台的架构来说。\n\n\n# 服务拆分\n\n讲到这个服务抽象和共享就顺便说说服务拆分的原则，这个说法太多了，见仁见智，更多的是遵循原有的一些经验去做处理。\n\n总的来说，现在我们主流的拆分都是根据业务角度去拆分。\n\n高内聚、低耦合，这个没啥说的，所有的服务都应该遵循这个原则，否则你要拆那就是瞎几把拆。\n\n高内聚说的是比如交易中台，只围绕交易相关的、依赖性非常高的进行拆分。\n\n低耦合则是说不同的服务，业务之间要隔离，不要耦合在一起，但是这个得有过程。\n\n举个例子来说一开始的业务没什么人，用户地址这些信息就放在用户的服务里，好像也没什么问题。\n\n随着业务的发展，这个地址信息和物流的服务好像关联越来越大，是不是就可以拆到物流服务里。\n\n所以，这个要用发展的眼光去看待问题，不能一刀切。\n\n回头去个小公司，别人就几万用户，几个程序员，就一个服务，你非要干微服务，拆几十个服务出来，这就不对是不是。\n\n数据完整性\n\n其实也类似，业务相关数据一定要完整，比如你做拆分，拆分完了之后用户名字拆到别的系统里去了，那就不太合理了。\n\n持续迭代\n\n也就是说要可持续性地做架构升级的调整和拆分，这个还是要跟着业务的发展走，不能一下拆的太细，也不能一下子太粗。。\n\n你能明白我的意思吧，我没有在开车。。\n\n\n# 交易中台\n\n说了好久，总算说到交易中台了，我之前干交易中台干了差不多两年时间，自认为还算比较了解，除了一些东西没有实现之外，由于公司发展和时间的关系。\n\n交易中台上面也提到过，主要就是从用户看到商品，然后到订单确认页，最后下订单，支付，配送，签收，这样一个整个过程都是交易中台在做的事情。\n\n交易的定义就是买卖双方对有价物品和服务进行互通有无的行为，可以是以货币为交易媒介的过程，也可以是以物易物。\n\n而交易过程，现在一般都是分为订约和履约两个，这基本是所有的交易中台的规则了。\n\n某某在什么时间做了什么事情，这是订约。\n\n举个例子来说，买方给卖方提供了有价物品，比如钱，卖方需要给买方提供服务。\n\n而履约的则是某某在约定的时间完成约定的事情，比如交付货币、物品或者服务。\n\n整个流程大致就是这个样子，当然一般我们都会分为正向和逆向两个方向去处理，正向完成交易的过程，逆向你可以理解为取消、退款这个环节。\n\n\n\n既然是中台，那么就要能适应各类的交易场景。\n\n比如酒店行业你去预订房间，这是正向交易，最后你去入住、离店，这是你履约的过程。\n\n供应链要采购，然后商家会发货，最后你签收，这也是订约和履约的过程。\n\n点外卖也是同样的道理。\n\n这些所有的场景，那么我们都可以用通用的流程来归纳起来，就是上面提到的通用的交易流程。\n\n\n\n抽象的概念说完了，需要再形象一点的来描述一下。\n\n上面我们说到了一些现在比较常见的服务拆分和服务的划分，下面根据实际场景看看我们服务到底是怎么划分的。\n\n这张图是美团的订单确认页，一般也叫做提单页。图太长，我拆分为3个小图来描述。\n\n可以一起来分析一下这个页面应该由哪些服务来构成，由谁来聚合这么多服务的接口？\n\n\n\n首先地址信息上面也提到过了， 这个由用户服务或者说是物流服务来提供比较合适。\n\n那配送时间这方面就应该由物流的算法来提供，他们会根据运力、天气、骑手一堆信息来计算一个比较合理的送达时间。\n\n\n\n中间这一部分商品的详细信息肯定由商品服务来提供。\n\n至于配送费啊、各种补贴、红包优惠券是不是该由营销来提供，这里其实会很复杂， 因为要计算各种条件的价格，计算出最终应该支付的金额，这个一般我们会由价格服务来输出。\n\n\n\n最下面这一部分叫做搭售，可以在下单的同时去购买会员，这个其实就相当于下了两个订单，一单是外卖单，另外一个订单就是搭售订单，购买会员的订单，最终两个订单合并支付，保持最终一致性就行了，下单成功，同时会员购买成功。\n\n最终下单成功之后发送消息，物流团队根据消息去履约配送，营销根据下单消息该送积分、送红包就怎么送，另外如果有搭售会员的话，还需要进行会员升级，这也是属于履约的一部分。\n\n这个地方还有两个挺有意思的点。\n\n第一个是扣库存的问题，应该是下单成功扣库存，还是支付成功扣库存（不用太考虑保存订单和扣库存分布式事务的问题，这个会保证最终一致性）。\n\n一般所有的业务都会下单就扣库存，但是这样会有一个问题。\n\n之前我们做活动，会把很多房间拿出来做优惠活动，单价就会便宜，但是库存有限，这个叫做尾房甩卖。\n\n很多黄牛就先去下单把库存占住，然后再卖给用户，马上取消订单，帮用户下单。\n\n所以我们之前有两种模式，针对这种类型的特殊情况会支付成功后才扣库存，普通模式像电商外卖一般没这种问题，都是下单就扣。\n\n还有一个就是这个券的问题，不知道大家发现了没有，买了会员送券，可以立刻使用，下面还标注了，本单可用。\n\n你肯定能想到这个问题，一般我们是券发给用户了才能用，这里下单成功后发消息->履约->发券，这个券都还没有怎么提前用。\n\n这又是一个交易系统里比较常见的，早两年应该是没有这个玩法的，也算是一个优化，一般会叫做虚拟券。\n\n下单的时候去核销优惠券，一般会给营销传一个特殊的标记和参数，营销根据这个判断做特殊的处理，至于具体的逻辑，我也不是很清楚，搞的挺复杂的就是了。\n\n再结合全景图看一下就清晰了和架构图看一下就清晰多了。\n\n\n\n\n# 金融中台\n\n金融中台不够纯粹，与其说是中台，不如说是事业部更合适一点，一般现在国内很多公司的金融中台基本都逃脱不了这几块的内容，很多都非常类似，就是根据不同的业务有点出入而已。\n\n\n\n支付是整个金融中台的核心，跳转的统一收银台又是支付的核心。\n\n清结算也很核心，非常重要，这个我也干过一段时间，预算，活动、券这是营销的角度，预算则是财务金融的角度。\n\n一般创建活动的时候一定要申请预算，活动创建设置库存数量，同时申请财务预算，一般情况都是1：1，创建成功不可以修改，库存可以临时改，但是预算改不了，除非重新申请。\n\n金融中台自己领会好吧。\n\n\n# 去中台化\n\n这一段我不能放，涉及到一些公司隐私的东西，但是可以聊聊其他的。\n\n比如开发流程，就我经历过的，中台这种部门一旦起来了，很容易一家独大，话语权太强，并且对于稳定性的要求太高，一定程度上阻碍了业务的开发。\n\n其次对于业务的支撑和快速发展，其实可能没有想象中的那么好，经历过的大家应该也都会有体会的。\n\n再者，中台这种产品必然涉及了太多的政治层面的博弈，我觉得SuperCell那种小公司玩得转确实可以，但是体量太大的公司玩的好挺难的，那体量不大的公司又没有太大必要搞什么鬼中台，你又不是啥游戏公司对不对，毕竟还是互联网公司为主，做业务开发为主。\n\n好了，言尽于此吧，文章来源于艾小仙。\n\nhttps://juejin.cn/post/7028151090654904333",
      "normalizedContent": "今天给大家分享一下关于架构和中台的一些东西。\n\n主要会介绍一下中台的来源，这个大家可能都比较清楚，网上的文章和视频啊一大堆。\n\n还有就是关于架构的发展过程不得不在中间说明一下，由此引申出来中台的诞生。\n\n最后会就关于交易中台和金融中台做一个介绍，因为我最近两年在其他公司做的一个是交易中台，还有一个就是金融中台相关的业务。\n\n> 公司内做的一个简单的分享，文章内容是我根据自己讲的还有录像又手撸了一遍，累。\n\n\n# 中台由来\n\n首先，来看一下中台的由来。\n\n中台的来源主要是阿里，他们在15年拜访在芬兰的一家游戏公司，也就是supercell。\n\n这家公司非常牛逼，号称是世界上最成功的的移动游戏公司，做出的游戏也非常有名，肯定很多人也玩过。\n\n比如部落战争、海岛奇兵等等。\n\n我也玩过一下他们的那个游戏，不过觉得没啥意思。\n\n这家公司的规模只有不到200人，公司的开发模式通常都会由2-7个人的小团队进行开发，这个在他们内部叫做cell，这也是他们公司名字的由来。\n\n开发过程通常是团队内部决定，然后用最快的时间开发出测试版本，如果受欢迎就继续干，否则的话就迅速放弃。\n\n产品失败之后，不光不会受到惩罚，他们还会搞个party来庆祝，庆祝自己学到了新的东西。\n\n不过我觉得挺奇葩的，要是都按照他们这个模式来，早期腾讯、阿里这些大公司都该死绝了。\n\n我们都知道，腾讯早期的时候想卖100万都没人要，马总实在没辙才只能硬着头皮继续做下去。\n\n但是，就是这样一家小公司，2015年的净利润达到了15亿美元，而且在2016年的时候被腾讯86亿美元收购。\n\n这些都不是重点哈，重点我们今天要讲的是他们的开发模式，为什么能快速开发一个新游戏出来？\n\n本来在我们想象中，开发一个新的游戏是一个很耗费时间精力的东西，几周开发一个还不错的游戏应该是很有难度的事情。\n\n重点就在于他们的”中台“，也是他们多年游戏沉淀下来的东西。\n\n他们在前面的很多年时间里对通用的游戏素材、算法等等做了很多沉淀。\n\n这也就是后面马云回来阿里之后大力搞的中台了。\n\n\n# 聊聊架构\n\n讲完中台的来历，在将中台之前，我们还是要先说说架构的发展过程。\n\n\n# 单体架构的时代\n\n在我刚刚上班的时候，大概是11年、12年基本上我接触到的项目都是这个样子。\n\n一个团队的所有东西都在一块，什么用户注册登录、支付啊、订单都在一起，经常是改一个小东西一个大项目都要跟着发布。\n\n一般单体的架构都是单进程的，这也是针对我们现在的微服务来说的，就是打个jar包或者war包上传就完事儿了，所有模块都在一个进程里，如果要升级或者重启，那整个应用服务都要重启。\n\n当然了，简单的项目划分模块分层还是有的，比如我们那时候常用的mvc模式。\n\n\n\n简单是很简单，但是同样缺点也是很明显的。\n\n第一点就是团队协同合作的成本高，如果说小公司没几个人还好，一旦业务快速发展起来，代码量感人，刚开始上班那会儿我的电脑经常就只能跑的动一个项目，不过好像也没有别的项目了。\n\n经常改一个简单的东西可能到处是冲突，更不要说一个大服务的发版问题。\n\n第二点，项目太复杂了，什么东西都是大杂烩，全在里面。\n\n第三点，数据库连接的问题，一个服务太大了，就一个数据库的集群，业务越来越多，服务器越来越多，到后面单机可能只搞个个位数的连接都要不够用了。\n\n所以，一般伴随拆分服务，数据库也会做拆分，独立的服务拥有独立的数据库。\n\n最后一点，拓展性的问题，所有的功能都在一个服务里，可能实际情况是某几个功能模块负载非常高，比如订单或者库存的服务，频繁的读写，这时候想要扩展很难搞。\n\n更严重的问题就是，如果一个模块出了问题，整个应用都不能用了。\n\n这时候没有办法了，只能拆分。\n\n因此就到了我们第二个架构模式，soa的时代。\n\n\n# soa(service-oriented architecture)\n\n我在饿了么工作那会儿，里面就有一大堆的soa的称呼，并且一直都是。\n\nsoa是什么意思呢，全名是这个service-oriented architecture，意思就是面向服务的架构，基本上和我们现在的微服务差不多一样。\n\nsoa的核心在于：松耦合和服务重用，当单体架构出现瓶颈的时候，首先想到的都是拆，soa时代的话，其实也已经就有了服务注册发现、服务治理这些概念了，和微服务可以说从认知上没有任何区别。\n\nsoa其实有两种模式，一种是中心化，一种是去中心化，下图中表示的就是中心化的服务调用方式。\n\n\n\n服务调用之间都通过esb服务总线，调用方之间屏蔽了接口的修改，esb要做服务请求路由、数据格式转换，各种http socket适配和接入，所有脏活累活都归他干了。\n\n这样很明显的看出来问题了。\n\n第一个就是请求，同样的请求次数是通常去中心化的2倍，本来a调用b，现在要通过esb。\n\n第二个是肉眼可见的问题，这个esb的压力会非常大，可以通过集群解决，但是esb的性能瓶颈会导致所有服务的瓶颈。\n\n但是，这个模式在当初非常受欢迎，主要原因是什么呢？\n\n就是烟囱式架构引发出来的问题。\n\n烟囱式架构是什么？\n\n\n\n就像这张图描述的，你有好几个业务，因为时间或者说团队、公司各种原因，搞成了好几套独立的服务，开发和运维都没啥关系，大多数公司之前的发展过程中都会存在这样的问题。\n\n比如我之前的公司先做酒店业务、然后又有外卖、还有餐饮店、还要卖咖啡。\n\n如果说来一个业务就重头搞一套用户体系、订单体系、库存体系，最终的结果就是像矗立起来的一个个烟囱，也就是烟囱式架构。\n\n烟囱的现象很普遍，大家各玩各的，先把业务跑起来再说，但是缺陷有很多。\n\n首先，重复建设开发，不用说都能看出来，每次重头搞一套，不说开发成本，就说服务器和运维成本都够头疼的。\n\n第二点，就是系统之间交互协作成本直线上升，业务发展了，可能要做一些精确营销活动，设计用户画像，对数据分析之类的啦，这都很正常。\n\n哦豁，这时候你发现用户在好几个系统里，这个交互打通的成本就太高了。\n\n要做个数据统计，还要调好几个系统接口，可能数据结构还不一样，搞都搞死你。\n\n还有就是业务沉淀和发展，这也是后面要说的中台了。\n\n难道这些系统之间就没有通用的能抽象的能力可以共用吗？\n\n这也就是中台的发展的方向，抽象、沉淀和共用。\n\n\n\n\n# 微服务架构\n\n最后就是说到我们的微服务时代了，这个大家都很熟悉，不需要说太多东西。\n\n至于现在还有serverless、云原生什么低代码这里就不展开了，等后面的话有机会再说。\n\n回到微服务的话题，微服务和soa有什么区别。\n\n个人认为其实很接近，微服务就是更加自由和更细粒度的soa。\n\n微服务没有那么多框架约束，我们想用啥用啥，虽然在soa也可以实现，比如通信我们可以用dubbo，可以用feign，thrift，grpc，想用啥用啥。\n\n举个例子用 spring cloud 来说，eureka可以帮我们做服务注册和发现，打个@enableeurekaclient就可以成为客户端连接到eureka了。\n\n路由直接用zuul，限流熔断用hystrix，负载均衡用ribbon，远程调用用feign。\n\n非常方便，当然还可以选择用spring cloud alibaba，这个我认为可能会是将来一段时间的趋势，更新维护的非常勤快。\n\ndubbo nacos sentinel这一套整起来明显更符合国内的使用习惯。\n\n\n# 服务共享\n\n说完架构的发展，可以回到我们之前的中台话题。\n\n那其实中台的作用已经不言而喻了，就是共享。\n\n以现在比较主流的一些电商来说，几个共享服务中心的划分。\n\n\n\n首先用户中心必不可少，用户是基础服务，用户中心集成用户通用的能力，包括注册登录，sso单点登录，还要和大数据配合用户打标签，用户画像等。\n\n营销中心这个也很重要，包含各种优惠活动、优惠券、红包、卡券、积分、会员等级、返佣之类的和营销相关的东西。\n\n交易中心处理用户下订单，如果下单有返佣，积分之类的话，这个叫做履约，后面再说，关于交易中台是我后面要说的。\n\n支付中心负责支付，退款，三方支付、银行对接、预算管控等等。\n\n数据中心，这个其实和业务中台是两块方向，今天我要说的都是业务中台，针对业务系统的沉淀和共享，数据中台则是更偏向大数据方向的，不在这里赘述。\n\n最底层服务是我们的基础设施和中间件的能力，比如数据库、消息服务kafka、rabbitmq、数仓、文件系统。\n\n这张图画出来好像除了中台和前台没别的东西了，并不是这样，我只是想表达说共享服务是作为支撑上层业务的核心，下层还有后台的服务并没有画出来而已，也就是顺应着大中台、小前台的架构来说。\n\n\n# 服务拆分\n\n讲到这个服务抽象和共享就顺便说说服务拆分的原则，这个说法太多了，见仁见智，更多的是遵循原有的一些经验去做处理。\n\n总的来说，现在我们主流的拆分都是根据业务角度去拆分。\n\n高内聚、低耦合，这个没啥说的，所有的服务都应该遵循这个原则，否则你要拆那就是瞎几把拆。\n\n高内聚说的是比如交易中台，只围绕交易相关的、依赖性非常高的进行拆分。\n\n低耦合则是说不同的服务，业务之间要隔离，不要耦合在一起，但是这个得有过程。\n\n举个例子来说一开始的业务没什么人，用户地址这些信息就放在用户的服务里，好像也没什么问题。\n\n随着业务的发展，这个地址信息和物流的服务好像关联越来越大，是不是就可以拆到物流服务里。\n\n所以，这个要用发展的眼光去看待问题，不能一刀切。\n\n回头去个小公司，别人就几万用户，几个程序员，就一个服务，你非要干微服务，拆几十个服务出来，这就不对是不是。\n\n数据完整性\n\n其实也类似，业务相关数据一定要完整，比如你做拆分，拆分完了之后用户名字拆到别的系统里去了，那就不太合理了。\n\n持续迭代\n\n也就是说要可持续性地做架构升级的调整和拆分，这个还是要跟着业务的发展走，不能一下拆的太细，也不能一下子太粗。。\n\n你能明白我的意思吧，我没有在开车。。\n\n\n# 交易中台\n\n说了好久，总算说到交易中台了，我之前干交易中台干了差不多两年时间，自认为还算比较了解，除了一些东西没有实现之外，由于公司发展和时间的关系。\n\n交易中台上面也提到过，主要就是从用户看到商品，然后到订单确认页，最后下订单，支付，配送，签收，这样一个整个过程都是交易中台在做的事情。\n\n交易的定义就是买卖双方对有价物品和服务进行互通有无的行为，可以是以货币为交易媒介的过程，也可以是以物易物。\n\n而交易过程，现在一般都是分为订约和履约两个，这基本是所有的交易中台的规则了。\n\n某某在什么时间做了什么事情，这是订约。\n\n举个例子来说，买方给卖方提供了有价物品，比如钱，卖方需要给买方提供服务。\n\n而履约的则是某某在约定的时间完成约定的事情，比如交付货币、物品或者服务。\n\n整个流程大致就是这个样子，当然一般我们都会分为正向和逆向两个方向去处理，正向完成交易的过程，逆向你可以理解为取消、退款这个环节。\n\n\n\n既然是中台，那么就要能适应各类的交易场景。\n\n比如酒店行业你去预订房间，这是正向交易，最后你去入住、离店，这是你履约的过程。\n\n供应链要采购，然后商家会发货，最后你签收，这也是订约和履约的过程。\n\n点外卖也是同样的道理。\n\n这些所有的场景，那么我们都可以用通用的流程来归纳起来，就是上面提到的通用的交易流程。\n\n\n\n抽象的概念说完了，需要再形象一点的来描述一下。\n\n上面我们说到了一些现在比较常见的服务拆分和服务的划分，下面根据实际场景看看我们服务到底是怎么划分的。\n\n这张图是美团的订单确认页，一般也叫做提单页。图太长，我拆分为3个小图来描述。\n\n可以一起来分析一下这个页面应该由哪些服务来构成，由谁来聚合这么多服务的接口？\n\n\n\n首先地址信息上面也提到过了， 这个由用户服务或者说是物流服务来提供比较合适。\n\n那配送时间这方面就应该由物流的算法来提供，他们会根据运力、天气、骑手一堆信息来计算一个比较合理的送达时间。\n\n\n\n中间这一部分商品的详细信息肯定由商品服务来提供。\n\n至于配送费啊、各种补贴、红包优惠券是不是该由营销来提供，这里其实会很复杂， 因为要计算各种条件的价格，计算出最终应该支付的金额，这个一般我们会由价格服务来输出。\n\n\n\n最下面这一部分叫做搭售，可以在下单的同时去购买会员，这个其实就相当于下了两个订单，一单是外卖单，另外一个订单就是搭售订单，购买会员的订单，最终两个订单合并支付，保持最终一致性就行了，下单成功，同时会员购买成功。\n\n最终下单成功之后发送消息，物流团队根据消息去履约配送，营销根据下单消息该送积分、送红包就怎么送，另外如果有搭售会员的话，还需要进行会员升级，这也是属于履约的一部分。\n\n这个地方还有两个挺有意思的点。\n\n第一个是扣库存的问题，应该是下单成功扣库存，还是支付成功扣库存（不用太考虑保存订单和扣库存分布式事务的问题，这个会保证最终一致性）。\n\n一般所有的业务都会下单就扣库存，但是这样会有一个问题。\n\n之前我们做活动，会把很多房间拿出来做优惠活动，单价就会便宜，但是库存有限，这个叫做尾房甩卖。\n\n很多黄牛就先去下单把库存占住，然后再卖给用户，马上取消订单，帮用户下单。\n\n所以我们之前有两种模式，针对这种类型的特殊情况会支付成功后才扣库存，普通模式像电商外卖一般没这种问题，都是下单就扣。\n\n还有一个就是这个券的问题，不知道大家发现了没有，买了会员送券，可以立刻使用，下面还标注了，本单可用。\n\n你肯定能想到这个问题，一般我们是券发给用户了才能用，这里下单成功后发消息->履约->发券，这个券都还没有怎么提前用。\n\n这又是一个交易系统里比较常见的，早两年应该是没有这个玩法的，也算是一个优化，一般会叫做虚拟券。\n\n下单的时候去核销优惠券，一般会给营销传一个特殊的标记和参数，营销根据这个判断做特殊的处理，至于具体的逻辑，我也不是很清楚，搞的挺复杂的就是了。\n\n再结合全景图看一下就清晰了和架构图看一下就清晰多了。\n\n\n\n\n# 金融中台\n\n金融中台不够纯粹，与其说是中台，不如说是事业部更合适一点，一般现在国内很多公司的金融中台基本都逃脱不了这几块的内容，很多都非常类似，就是根据不同的业务有点出入而已。\n\n\n\n支付是整个金融中台的核心，跳转的统一收银台又是支付的核心。\n\n清结算也很核心，非常重要，这个我也干过一段时间，预算，活动、券这是营销的角度，预算则是财务金融的角度。\n\n一般创建活动的时候一定要申请预算，活动创建设置库存数量，同时申请财务预算，一般情况都是1：1，创建成功不可以修改，库存可以临时改，但是预算改不了，除非重新申请。\n\n金融中台自己领会好吧。\n\n\n# 去中台化\n\n这一段我不能放，涉及到一些公司隐私的东西，但是可以聊聊其他的。\n\n比如开发流程，就我经历过的，中台这种部门一旦起来了，很容易一家独大，话语权太强，并且对于稳定性的要求太高，一定程度上阻碍了业务的开发。\n\n其次对于业务的支撑和快速发展，其实可能没有想象中的那么好，经历过的大家应该也都会有体会的。\n\n再者，中台这种产品必然涉及了太多的政治层面的博弈，我觉得supercell那种小公司玩得转确实可以，但是体量太大的公司玩的好挺难的，那体量不大的公司又没有太大必要搞什么鬼中台，你又不是啥游戏公司对不对，毕竟还是互联网公司为主，做业务开发为主。\n\n好了，言尽于此吧，文章来源于艾小仙。\n\nhttps://juejin.cn/post/7028151090654904333",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/12/16, 11:26:19",
      "lastUpdatedTimestamp": 1639625179000
    },
    {
      "title": "Java实现常见的负载均衡算法",
      "frontmatter": {
        "title": "Java实现常见的负载均衡算法",
        "date": "2022-08-08T00:00:00.000Z",
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20220808.html",
      "relativePath": "views/essay/20220808.md",
      "key": "v-1d8345ed",
      "path": "/views/essay/20220808.html",
      "headers": [
        {
          "level": 2,
          "title": "什么是负载均衡",
          "slug": "什么是负载均衡",
          "normalizedTitle": "什么是负载均衡",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "常见的负载均衡算法",
          "slug": "常见的负载均衡算法",
          "normalizedTitle": "常见的负载均衡算法",
          "charIndex": 233
        },
        {
          "level": 3,
          "title": "1.轮询（Round Robin）",
          "slug": "_1-轮询-round-robin",
          "normalizedTitle": "1.轮询（round robin）",
          "charIndex": 247
        },
        {
          "level": 3,
          "title": "2.加权轮询（WeightedRound-Robin）",
          "slug": "_2-加权轮询-weightedround-robin",
          "normalizedTitle": "2.加权轮询（weightedround-robin）",
          "charIndex": 2254
        },
        {
          "level": 3,
          "title": "3.随机（Random）",
          "slug": "_3-随机-random",
          "normalizedTitle": "3.随机（random）",
          "charIndex": 5049
        },
        {
          "level": 3,
          "title": "4.加权随机（Weight Random）",
          "slug": "_4-加权随机-weight-random",
          "normalizedTitle": "4.加权随机（weight random）",
          "charIndex": 6154
        },
        {
          "level": 3,
          "title": "5.IPHash",
          "slug": "_5-iphash",
          "normalizedTitle": "5.iphash",
          "charIndex": 8037
        },
        {
          "level": 3,
          "title": "6.最小连接数算法（ LeastConnection）",
          "slug": "_6-最小连接数算法-leastconnection",
          "normalizedTitle": "6.最小连接数算法（ leastconnection）",
          "charIndex": 9259
        },
        {
          "level": 2,
          "title": "参考",
          "slug": "参考",
          "normalizedTitle": "参考",
          "charIndex": 11285
        }
      ],
      "excerpt": "<Boxx/>\n",
      "headersStr": "什么是负载均衡 常见的负载均衡算法 1.轮询（Round Robin） 2.加权轮询（WeightedRound-Robin） 3.随机（Random） 4.加权随机（Weight Random） 5.IPHash 6.最小连接数算法（ LeastConnection） 参考",
      "content": "# 什么是负载均衡\n\n负载平衡（Load balancing）是一种电子计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。\n\n\n# 常见的负载均衡算法\n\n\n# 1.轮询（Round Robin）\n\n轮询算法按照顺序将新的请求分配给下一个服务器，最终实现平分请求。\n\n实例：已知服务器： s1 ，s2， s3\n\n请求1 -> s1\n\n请求2-> s2\n\n请求3 -> s3\n\n请求4 -> s1\n\n请求5 -> s2\n\n请求6 -> s3\n\n…\n\n优点：\n\n实现简单，无需记录各种服务的状态，是一种无状态的负载均衡策略。\n\n实现绝对公平\n\n缺点：当各个服务器性能不一致的情况，无法根据服务器性能去分配，无法合理利用服务器资源。\n\njava实现轮询算法：\n\n思路：根据上面的介绍，依次的选择下一个服务器，轮询算法具有周期性的特性，这就是典型的周期性概念，我们第一想法应该就是取余了。\n\n这里推荐大家《程序员的数学1》里面介绍了一些数学和编程思维的一些案例，其中就有介绍周期和分组的思想，个人感觉这本书还是不错的，推荐给大家。\n\npublic class RoundRobin {\n\n    @Data\n    public static class Server {\n\n        private int serverId;\n\n        private String name;\n\n        private int weight;\n\n        public Server(int serverId, String name) {\n            this.serverId = serverId;\n            this.name = name;\n        }\n\n        public Server(int serverId, String name, int weight) {\n            this.serverId = serverId;\n            this.name = name;\n            this.weight = weight;\n        }\n    }\n\n    private static AtomicInteger NEXT_SERVER_COUNTER = new AtomicInteger(0);\n\n    private static int select(int modulo) {\n        for (; ; ) {\n            int current = NEXT_SERVER_COUNTER.get();\n            int next = (current + 1) % modulo;\n            boolean compareAndSet = NEXT_SERVER_COUNTER.compareAndSet(current, next);\n            if (compareAndSet) {\n                return next;\n            }\n        }\n    }\n\n    public static Server selectServer(List<Server> serverList) {\n        return serverList.get(select(serverList.size()));\n    }\n\n    public static void main(String[] args) {\n        List<Server> serverList = new ArrayList<>();\n        serverList.add(new Server(1, \"服务器1\"));\n        serverList.add(new Server(2, \"服务器2\"));\n        serverList.add(new Server(3, \"服务器3\"));\n        for (int i = 0; i < 10; i++) {\n            Server selectedServer = selectServer(serverList);\n            System.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, selectedServer.toString());\n\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n\n\n# 2.加权轮询（WeightedRound-Robin）\n\n由于不同的服务器配置不同，因此它们处理请求的能力也不同，给配置高的机器配置相对较高的权重，让其处理更多的请求，给配置较低的机器配置较低的权重减轻期负载压力。加权轮询可以较好的解决这个问题。\n\n思路：\n\n根据权重的大小让其获得相应被轮询到的机会。\n\n已知：\n\n服务器   权重\ns1    1\ns2    2\ns3    3\n\n可以根据权重我们在内存中创建一个这样的数组{s1,s2,s2,s3,s3,s3}，然后再按照轮询的方式选择相应的服务器。\n\n缺点：请求被分配到三台服务器上机会不够平滑。前3次请求都不会落在server3上。\n\nNginx 实现了一种平滑的加权轮询算法，可以将请求平滑（均匀）的分配到各个节点上。\n\n下面我们用Java实现一下这个算法。\n\n实现思路\n\n我们以当前节点权重作为被选中的概率\n\n public void incrCurrentWeight() {\n      this.currentWeight += weight;\n }\n\n\n1\n2\n3\n\n\n为了避免权重大的被连续选中，所以再被选中的时候我们应该让其的当前权重变小。我们可以采用\n\n// 当前权重 = 当前权重 - 总权重 1-6 =-5\n\n3-6 =-3\n\n可得权重越大下次当前权重变成最大的可能性也越大\n\npublic void selected(int total) {\n    this.currentWeight -= total;\n}\n\n\n1\n2\n3\n\n\n我们选取当前当前权重最大的一个服务器\n\npublic class WeightRoundRobin {\n\n    @Data\n    public static class Server {\n\n        private int serverId;\n\n        private String name;\n\n        private int weight;\n\n        private int currentWeight;\n\n        public Server(int serverId, String name) {\n            this.serverId = serverId;\n            this.name = name;\n        }\n\n        public Server(int serverId, String name, int weight) {\n            this.serverId = serverId;\n            this.name = name;\n            this.weight = weight;\n        }\n\n        public void selected(int total) {\n            this.currentWeight -= total;\n        }\n\n        public void incrCurrentWeight() {\n            this.currentWeight += weight;\n        }\n    }\n\n    public static Server selectServer(List<Server> serverList) {\n        int total = 0;\n        Server selectedServer = null;\n        int maxWeight = 0;\n        for (Server server : serverList) {\n            total += server.getWeight();\n            server.incrCurrentWeight();\n          \t//选取当前权重最大的一个服务器\n            if (selectedServer == null || maxWeight < server.getCurrentWeight()) {\n                selectedServer = server;\n                maxWeight = server.getCurrentWeight();\n            }\n        }\n        if (selectedServer == null){\n            Random random = new Random();\n            int next = random.nextInt(serverList.size());\n            return serverList.get(next);\n        }\n        selectedServer.selected(total);\n        return selectedServer;\n    }\n\n\n    public static void main(String[] args) {\n        List<Server> serverList = new ArrayList<>();\n        serverList.add(new Server(1, \"服务器1\", 1));\n        serverList.add(new Server(2, \"服务器2\", 3));\n        serverList.add(new Server(3, \"服务器3\", 10));\n        for (int i = 0; i < 10; i++) {\n            Server server = selectServer(serverList);\n            System.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, server.toString());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n\n\n# 3.随机（Random）\n\n思路：利用随机数从所有服务器中随机选取一台，可以用服务器数组下标获取。\n\npublic class RandomLoadBalance {\n\n    @Data\n    public static class Server {\n\n        private int serverId;\n\n        private String name;\n\n        private int weight;\n\n        public Server(int serverId, String name) {\n            this.serverId = serverId;\n            this.name = name;\n        }\n    }\n\n    public static Server selectServer(List<Server> serverList) {\n        Random selector = new Random();\n        int next = selector.nextInt(serverList.size());\n        return serverList.get(next);\n    }\n\n    public static void main(String[] args) {\n        List<Server> serverList = new ArrayList<>();\n        serverList.add(new Server(1, \"服务器1\"));\n        serverList.add(new Server(2, \"服务器2\"));\n        serverList.add(new Server(3, \"服务器3\"));\n        for (int i = 0; i < 10; i++) {\n            Server selectedServer = selectServer(serverList);\n            System.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, selectedServer.toString());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n\n\n# 4.加权随机（Weight Random）\n\n思路：\n\n这里我们是利用区间的思想，通过一个小于在此区间范围内的一个随机数，选中对应的区间（服务器），区间越大被选中的概率就越大。\n\n已知：\n\n服务器   权重\ns1    1\ns2    2\ns3    3\n\ns1：[0,1] s2：(1,3] s3 （3,6]\n\npublic class WeightRandom {\n\n    @Data\n    public static class Server {\n\n        private int serverId;\n\n        private String name;\n\n        private int weight;\n\n        public Server(int serverId, String name) {\n            this.serverId = serverId;\n            this.name = name;\n        }\n\n        public Server(int serverId, String name, int weight) {\n            this.serverId = serverId;\n            this.name = name;\n            this.weight = weight;\n        }\n    }\n\n    private static Server selectServer(List<Server> serverList) {\n        int sumWeight = 0;\n        for (Server server : serverList) {\n            sumWeight += server.getWeight();\n        }\n        Random serverSelector = new Random();\n        int nextServerRange = serverSelector.nextInt(sumWeight);\n        int sum = 0;\n        Server selectedServer = null;\n        for (Server server : serverList) {\n            if (nextServerRange >= sum && nextServerRange < server.getWeight() + sum) {\n                selectedServer = server;\n            }\n            sum += server.getWeight();\n        }\n        return selectedServer;\n    }\n\n    public static void main(String[] args) {\n        List<Server> serverList = new ArrayList<>();\n        serverList.add(new Server(1, \"服务器1\", 1));\n        serverList.add(new Server(2, \"服务器2\", 5));\n        serverList.add(new Server(3, \"服务器3\", 10));\n        for (int i = 0; i < 10; i++) {\n            Server selectedServer = selectServer(serverList);\n            System.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, selectedServer.toString());\n\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n\n\n# 5.IPHash\n\n思路：根据每个每个请求ip（也可以是某个标识）ip.hash() % server.size()\n\npublic class IpHash {\n\n    @Data\n    public static class Server {\n\n        private int serverId;\n\n        private String name;\n\n        public Server(int serverId, String name) {\n            this.serverId = serverId;\n            this.name = name;\n        }\n    }\n\n    public static Server selectServer(List<Server> serverList, String ip) {\n        int ipHash = ip.hashCode();\n        return serverList.get(ipHash % serverList.size());\n    }\n\n    public static void main(String[] args) {\n        List<Server> serverList = new ArrayList<>();\n        serverList.add(new Server(1, \"服务器1\"));\n        serverList.add(new Server(2, \"服务器2\"));\n        serverList.add(new Server(3, \"服务器3\"));\n\n        List<String> ips = Arrays.asList(\"192.168.9.5\", \"192.168.9.2\", \"192.168.9.3\");\n        for (int i = 0; i < 10; i++) {\n            for (String ip : ips) {\n                Server selectedServer = selectServer(serverList, ip);\n                System.out.format(\"请求ip:%s，选择服务器%s\\n\", ip, selectedServer.toString());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n\n可以看到结果：同一ip肯定会命中同一台机器。\n\n\n# 6.最小连接数算法（ LeastConnection）\n\n前面我们费尽心思来实现服务消费者请求次数分配的均衡，我们知道这样做是没错的，可以为后端的多台服务器平均分配工作量，最大程度地提高服务器的利用率，但是，实际上，请求次数的均衡并不代表负载的均衡。因此我们需要介绍最小连接数法，最小连接数法比较灵活和智能，由于后台服务器的配置不尽相同，对请求的处理有快有慢，它正是根据后端服务器当前的连接情况，动态的选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能的提高后台服务器利用率，将负载合理的分流到每一台服务器。\n\n/**\n * 最小连接数法是根据服务器当前的连接情况进行负载均衡的，当请求到来时，会选取当前连接数最少的一台服务器来处理请求。\n */\npublic class LeastConnection {\n    /**\n     * 定义map\n     * key：模拟后台服务的ip\n     * value：一个Map，map的key是权重，value是接受请求的次数，\n     */\n    static Map<String, Integer> ipMap = new HashMap<>();\n    //模拟请求的次数\n    static ThreadLocalRandom random = ThreadLocalRandom.current();\n\n    static {\n        ipMap.put(\"192.168.13.1\", random.nextInt(10));\n        ipMap.put(\"192.168.13.2\", random.nextInt(10));\n        ipMap.put(\"192.168.13.3\", random.nextInt(10));\n    }\n\n    //从list中选取接受请求数最少的服务并返回\n    public String leastConnection() {\n        Iterator<String> ipListIterator = ipMap.keySet().iterator();\n        String serverName = null;\n        int times = 0;//访问次数\n        while (ipListIterator.hasNext()) {\n            String tmpServerName = ipListIterator.next();\n            int requestTimes = ipMap.get(tmpServerName);\n            //第一次需要赋值\n            if (times == 0) {\n                serverName = tmpServerName;\n                times = requestTimes;\n            } else {\n                //找到最小次数\n                if (times > requestTimes) {\n                    serverName = tmpServerName;\n                    times = requestTimes;\n                }\n            }\n        }\n        ipMap.put(serverName, ++times);//访问后+1\n        System.out.println(\"获取到的地址是：\" + serverName + \", 访问次数：\" + times);\n        return serverName;\n    }\n\n    public static void main(String[] args) {\n        TestLeastConnection testLeastConnection = new TestLeastConnection();\n        for (int i = 0; i < 10; i++) {\n            testLeastConnection.leastConnection();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 参考\n\n * https://blog.csdn.net/u011047968/article/details/99844116\n * https://blog.csdn.net/mountain9527/article/details/119960229",
      "normalizedContent": "# 什么是负载均衡\n\n负载平衡（load balancing）是一种电子计算机技术，用来在多个计算机（计算机集群）、网络连接、cpu、磁盘驱动器或其他资源中分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。\n\n\n# 常见的负载均衡算法\n\n\n# 1.轮询（round robin）\n\n轮询算法按照顺序将新的请求分配给下一个服务器，最终实现平分请求。\n\n实例：已知服务器： s1 ，s2， s3\n\n请求1 -> s1\n\n请求2-> s2\n\n请求3 -> s3\n\n请求4 -> s1\n\n请求5 -> s2\n\n请求6 -> s3\n\n…\n\n优点：\n\n实现简单，无需记录各种服务的状态，是一种无状态的负载均衡策略。\n\n实现绝对公平\n\n缺点：当各个服务器性能不一致的情况，无法根据服务器性能去分配，无法合理利用服务器资源。\n\njava实现轮询算法：\n\n思路：根据上面的介绍，依次的选择下一个服务器，轮询算法具有周期性的特性，这就是典型的周期性概念，我们第一想法应该就是取余了。\n\n这里推荐大家《程序员的数学1》里面介绍了一些数学和编程思维的一些案例，其中就有介绍周期和分组的思想，个人感觉这本书还是不错的，推荐给大家。\n\npublic class roundrobin {\n\n    @data\n    public static class server {\n\n        private int serverid;\n\n        private string name;\n\n        private int weight;\n\n        public server(int serverid, string name) {\n            this.serverid = serverid;\n            this.name = name;\n        }\n\n        public server(int serverid, string name, int weight) {\n            this.serverid = serverid;\n            this.name = name;\n            this.weight = weight;\n        }\n    }\n\n    private static atomicinteger next_server_counter = new atomicinteger(0);\n\n    private static int select(int modulo) {\n        for (; ; ) {\n            int current = next_server_counter.get();\n            int next = (current + 1) % modulo;\n            boolean compareandset = next_server_counter.compareandset(current, next);\n            if (compareandset) {\n                return next;\n            }\n        }\n    }\n\n    public static server selectserver(list<server> serverlist) {\n        return serverlist.get(select(serverlist.size()));\n    }\n\n    public static void main(string[] args) {\n        list<server> serverlist = new arraylist<>();\n        serverlist.add(new server(1, \"服务器1\"));\n        serverlist.add(new server(2, \"服务器2\"));\n        serverlist.add(new server(3, \"服务器3\"));\n        for (int i = 0; i < 10; i++) {\n            server selectedserver = selectserver(serverlist);\n            system.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, selectedserver.tostring());\n\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n\n\n# 2.加权轮询（weightedround-robin）\n\n由于不同的服务器配置不同，因此它们处理请求的能力也不同，给配置高的机器配置相对较高的权重，让其处理更多的请求，给配置较低的机器配置较低的权重减轻期负载压力。加权轮询可以较好的解决这个问题。\n\n思路：\n\n根据权重的大小让其获得相应被轮询到的机会。\n\n已知：\n\n服务器   权重\ns1    1\ns2    2\ns3    3\n\n可以根据权重我们在内存中创建一个这样的数组{s1,s2,s2,s3,s3,s3}，然后再按照轮询的方式选择相应的服务器。\n\n缺点：请求被分配到三台服务器上机会不够平滑。前3次请求都不会落在server3上。\n\nnginx 实现了一种平滑的加权轮询算法，可以将请求平滑（均匀）的分配到各个节点上。\n\n下面我们用java实现一下这个算法。\n\n实现思路\n\n我们以当前节点权重作为被选中的概率\n\n public void incrcurrentweight() {\n      this.currentweight += weight;\n }\n\n\n1\n2\n3\n\n\n为了避免权重大的被连续选中，所以再被选中的时候我们应该让其的当前权重变小。我们可以采用\n\n// 当前权重 = 当前权重 - 总权重 1-6 =-5\n\n3-6 =-3\n\n可得权重越大下次当前权重变成最大的可能性也越大\n\npublic void selected(int total) {\n    this.currentweight -= total;\n}\n\n\n1\n2\n3\n\n\n我们选取当前当前权重最大的一个服务器\n\npublic class weightroundrobin {\n\n    @data\n    public static class server {\n\n        private int serverid;\n\n        private string name;\n\n        private int weight;\n\n        private int currentweight;\n\n        public server(int serverid, string name) {\n            this.serverid = serverid;\n            this.name = name;\n        }\n\n        public server(int serverid, string name, int weight) {\n            this.serverid = serverid;\n            this.name = name;\n            this.weight = weight;\n        }\n\n        public void selected(int total) {\n            this.currentweight -= total;\n        }\n\n        public void incrcurrentweight() {\n            this.currentweight += weight;\n        }\n    }\n\n    public static server selectserver(list<server> serverlist) {\n        int total = 0;\n        server selectedserver = null;\n        int maxweight = 0;\n        for (server server : serverlist) {\n            total += server.getweight();\n            server.incrcurrentweight();\n          \t//选取当前权重最大的一个服务器\n            if (selectedserver == null || maxweight < server.getcurrentweight()) {\n                selectedserver = server;\n                maxweight = server.getcurrentweight();\n            }\n        }\n        if (selectedserver == null){\n            random random = new random();\n            int next = random.nextint(serverlist.size());\n            return serverlist.get(next);\n        }\n        selectedserver.selected(total);\n        return selectedserver;\n    }\n\n\n    public static void main(string[] args) {\n        list<server> serverlist = new arraylist<>();\n        serverlist.add(new server(1, \"服务器1\", 1));\n        serverlist.add(new server(2, \"服务器2\", 3));\n        serverlist.add(new server(3, \"服务器3\", 10));\n        for (int i = 0; i < 10; i++) {\n            server server = selectserver(serverlist);\n            system.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, server.tostring());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n\n\n# 3.随机（random）\n\n思路：利用随机数从所有服务器中随机选取一台，可以用服务器数组下标获取。\n\npublic class randomloadbalance {\n\n    @data\n    public static class server {\n\n        private int serverid;\n\n        private string name;\n\n        private int weight;\n\n        public server(int serverid, string name) {\n            this.serverid = serverid;\n            this.name = name;\n        }\n    }\n\n    public static server selectserver(list<server> serverlist) {\n        random selector = new random();\n        int next = selector.nextint(serverlist.size());\n        return serverlist.get(next);\n    }\n\n    public static void main(string[] args) {\n        list<server> serverlist = new arraylist<>();\n        serverlist.add(new server(1, \"服务器1\"));\n        serverlist.add(new server(2, \"服务器2\"));\n        serverlist.add(new server(3, \"服务器3\"));\n        for (int i = 0; i < 10; i++) {\n            server selectedserver = selectserver(serverlist);\n            system.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, selectedserver.tostring());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n\n\n# 4.加权随机（weight random）\n\n思路：\n\n这里我们是利用区间的思想，通过一个小于在此区间范围内的一个随机数，选中对应的区间（服务器），区间越大被选中的概率就越大。\n\n已知：\n\n服务器   权重\ns1    1\ns2    2\ns3    3\n\ns1：[0,1] s2：(1,3] s3 （3,6]\n\npublic class weightrandom {\n\n    @data\n    public static class server {\n\n        private int serverid;\n\n        private string name;\n\n        private int weight;\n\n        public server(int serverid, string name) {\n            this.serverid = serverid;\n            this.name = name;\n        }\n\n        public server(int serverid, string name, int weight) {\n            this.serverid = serverid;\n            this.name = name;\n            this.weight = weight;\n        }\n    }\n\n    private static server selectserver(list<server> serverlist) {\n        int sumweight = 0;\n        for (server server : serverlist) {\n            sumweight += server.getweight();\n        }\n        random serverselector = new random();\n        int nextserverrange = serverselector.nextint(sumweight);\n        int sum = 0;\n        server selectedserver = null;\n        for (server server : serverlist) {\n            if (nextserverrange >= sum && nextserverrange < server.getweight() + sum) {\n                selectedserver = server;\n            }\n            sum += server.getweight();\n        }\n        return selectedserver;\n    }\n\n    public static void main(string[] args) {\n        list<server> serverlist = new arraylist<>();\n        serverlist.add(new server(1, \"服务器1\", 1));\n        serverlist.add(new server(2, \"服务器2\", 5));\n        serverlist.add(new server(3, \"服务器3\", 10));\n        for (int i = 0; i < 10; i++) {\n            server selectedserver = selectserver(serverlist);\n            system.out.format(\"第%d次请求，选择服务器%s\\n\", i + 1, selectedserver.tostring());\n\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n\n\n# 5.iphash\n\n思路：根据每个每个请求ip（也可以是某个标识）ip.hash() % server.size()\n\npublic class iphash {\n\n    @data\n    public static class server {\n\n        private int serverid;\n\n        private string name;\n\n        public server(int serverid, string name) {\n            this.serverid = serverid;\n            this.name = name;\n        }\n    }\n\n    public static server selectserver(list<server> serverlist, string ip) {\n        int iphash = ip.hashcode();\n        return serverlist.get(iphash % serverlist.size());\n    }\n\n    public static void main(string[] args) {\n        list<server> serverlist = new arraylist<>();\n        serverlist.add(new server(1, \"服务器1\"));\n        serverlist.add(new server(2, \"服务器2\"));\n        serverlist.add(new server(3, \"服务器3\"));\n\n        list<string> ips = arrays.aslist(\"192.168.9.5\", \"192.168.9.2\", \"192.168.9.3\");\n        for (int i = 0; i < 10; i++) {\n            for (string ip : ips) {\n                server selectedserver = selectserver(serverlist, ip);\n                system.out.format(\"请求ip:%s，选择服务器%s\\n\", ip, selectedserver.tostring());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n\n可以看到结果：同一ip肯定会命中同一台机器。\n\n\n# 6.最小连接数算法（ leastconnection）\n\n前面我们费尽心思来实现服务消费者请求次数分配的均衡，我们知道这样做是没错的，可以为后端的多台服务器平均分配工作量，最大程度地提高服务器的利用率，但是，实际上，请求次数的均衡并不代表负载的均衡。因此我们需要介绍最小连接数法，最小连接数法比较灵活和智能，由于后台服务器的配置不尽相同，对请求的处理有快有慢，它正是根据后端服务器当前的连接情况，动态的选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能的提高后台服务器利用率，将负载合理的分流到每一台服务器。\n\n/**\n * 最小连接数法是根据服务器当前的连接情况进行负载均衡的，当请求到来时，会选取当前连接数最少的一台服务器来处理请求。\n */\npublic class leastconnection {\n    /**\n     * 定义map\n     * key：模拟后台服务的ip\n     * value：一个map，map的key是权重，value是接受请求的次数，\n     */\n    static map<string, integer> ipmap = new hashmap<>();\n    //模拟请求的次数\n    static threadlocalrandom random = threadlocalrandom.current();\n\n    static {\n        ipmap.put(\"192.168.13.1\", random.nextint(10));\n        ipmap.put(\"192.168.13.2\", random.nextint(10));\n        ipmap.put(\"192.168.13.3\", random.nextint(10));\n    }\n\n    //从list中选取接受请求数最少的服务并返回\n    public string leastconnection() {\n        iterator<string> iplistiterator = ipmap.keyset().iterator();\n        string servername = null;\n        int times = 0;//访问次数\n        while (iplistiterator.hasnext()) {\n            string tmpservername = iplistiterator.next();\n            int requesttimes = ipmap.get(tmpservername);\n            //第一次需要赋值\n            if (times == 0) {\n                servername = tmpservername;\n                times = requesttimes;\n            } else {\n                //找到最小次数\n                if (times > requesttimes) {\n                    servername = tmpservername;\n                    times = requesttimes;\n                }\n            }\n        }\n        ipmap.put(servername, ++times);//访问后+1\n        system.out.println(\"获取到的地址是：\" + servername + \", 访问次数：\" + times);\n        return servername;\n    }\n\n    public static void main(string[] args) {\n        testleastconnection testleastconnection = new testleastconnection();\n        for (int i = 0; i < 10; i++) {\n            testleastconnection.leastconnection();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 参考\n\n * https://blog.csdn.net/u011047968/article/details/99844116\n * https://blog.csdn.net/mountain9527/article/details/119960229",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2023/06/06, 10:42:34",
      "lastUpdatedTimestamp": 1686019354000
    },
    {
      "title": "我爱你，爱的却不是那么尽如人意",
      "frontmatter": {
        "title": "我爱你，爱的却不是那么尽如人意",
        "date": "2020-10-12T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "keys": [
          "5201314"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20201012.html",
      "relativePath": "views/essay/20201012.md",
      "key": "v-f070eade",
      "path": "/views/essay/20201012.html",
      "headers": [
        {
          "level": 2,
          "title": "爱之初体验",
          "slug": "爱之初体验",
          "normalizedTitle": "爱之初体验",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "爱是你我，用心交织的生活",
          "slug": "爱是你我-用心交织的生活",
          "normalizedTitle": "爱是你我，用心交织的生活",
          "charIndex": 196
        },
        {
          "level": 2,
          "title": "爱要向前进",
          "slug": "爱要向前进",
          "normalizedTitle": "爱要向前进",
          "charIndex": 901
        }
      ],
      "headersStr": "爱之初体验 爱是你我，用心交织的生活 爱要向前进",
      "content": "# 爱之初体验\n\n亲爱的，开头请允许我引用昨晚曾说过的一句话：“我爱你，但爱的却不是那么尽如人意！”，因为这将是全文的重点，也是引领我之后成为一个“合格男友”的重要指示。\n\n首先说一下我自己吧，我这个人长久下来你可能也会发现最大的毛病就是不会与人交流（其他人我不管，单说你），不善表达，脑子里不记事，从小就一直被人说太老实太内向，这是与生俱来的毛病，想过改，但自己终究还是自己。\n\n\n\n\n# 爱是你我，用心交织的生活\n\n接下来说说正事\n\n生气，吵架，这是每对情侣都会发生的事情，结婚之后更是如此。\n\n确实，在恋爱方面我更是不善于表达，包括想的说的做的等一切，是真的不善于表达是脑子里都没有冒出那种想法一直是空白那种都傻傻的不知道说什么一直等对方开话题那种，你能理解的吧？\n\n不懂得关心不知道照顾对方的感受，尤其是经历过这么多事以后，越发认识到自己的错误，但是每每当问题发生时，仍不知道自己错在哪，这是最致命的，我是多想希望啊，多想希望能get到你那个点，然后知错能改善莫大焉！从你能感受到的地方开始呵护你关心你，完犊子了这个真的只是说说因为我实在不知道从哪方面下手，照我的理解就是明天多找你然后多陪你。\n\n有时候我说 我也不知道怎么办了是真的不知道怎么办了，因为第一我不敢瞎说第二我怕说错了又惹你生气，还有时候我怕我天天光说做不到而你到时候更失望，因为你不止一次说过类似的话：“你告诉我我很重要，你认定我了，你会好好对我，可你的表现却不是这样”，你知道吗，光是最后几个字，每看到一次就伤心一次，我真的很努力了，每每看到发“你的表现却不是这样”，我不知道是是你真的不满意还是我真的没做好，导致我也真的真的很内疚。\n\n而应对它我也一直说一直说我想变，变成那么一个大暖男好男友，或如你期望的那样（虽然我至今还不知道），主动关心你爱护你把你捧在手心里，这真的不是你的压力也不是你的要求，这些也真的是一个合格男友该做的事情，所以你不必自责！\n\n或许你也发现了，“真的”这两个字出现的次数太多太频繁了，说这么多一是表达出强调作用，二是“真的”想表达出我爱你，是从心里的爱，虽然不如你期望的爱！( T_T)\n\n\n# 爱要向前进\n\n\n\n我记得你也说过，缺点是每个人都有的，而爱情教会则是教会了彼此包容。以后的路还很长，生气吵架拌嘴是少不了的，但是不管发生什么，希望余生，有你陪我度过！",
      "normalizedContent": "# 爱之初体验\n\n亲爱的，开头请允许我引用昨晚曾说过的一句话：“我爱你，但爱的却不是那么尽如人意！”，因为这将是全文的重点，也是引领我之后成为一个“合格男友”的重要指示。\n\n首先说一下我自己吧，我这个人长久下来你可能也会发现最大的毛病就是不会与人交流（其他人我不管，单说你），不善表达，脑子里不记事，从小就一直被人说太老实太内向，这是与生俱来的毛病，想过改，但自己终究还是自己。\n\n\n\n\n# 爱是你我，用心交织的生活\n\n接下来说说正事\n\n生气，吵架，这是每对情侣都会发生的事情，结婚之后更是如此。\n\n确实，在恋爱方面我更是不善于表达，包括想的说的做的等一切，是真的不善于表达是脑子里都没有冒出那种想法一直是空白那种都傻傻的不知道说什么一直等对方开话题那种，你能理解的吧？\n\n不懂得关心不知道照顾对方的感受，尤其是经历过这么多事以后，越发认识到自己的错误，但是每每当问题发生时，仍不知道自己错在哪，这是最致命的，我是多想希望啊，多想希望能get到你那个点，然后知错能改善莫大焉！从你能感受到的地方开始呵护你关心你，完犊子了这个真的只是说说因为我实在不知道从哪方面下手，照我的理解就是明天多找你然后多陪你。\n\n有时候我说 我也不知道怎么办了是真的不知道怎么办了，因为第一我不敢瞎说第二我怕说错了又惹你生气，还有时候我怕我天天光说做不到而你到时候更失望，因为你不止一次说过类似的话：“你告诉我我很重要，你认定我了，你会好好对我，可你的表现却不是这样”，你知道吗，光是最后几个字，每看到一次就伤心一次，我真的很努力了，每每看到发“你的表现却不是这样”，我不知道是是你真的不满意还是我真的没做好，导致我也真的真的很内疚。\n\n而应对它我也一直说一直说我想变，变成那么一个大暖男好男友，或如你期望的那样（虽然我至今还不知道），主动关心你爱护你把你捧在手心里，这真的不是你的压力也不是你的要求，这些也真的是一个合格男友该做的事情，所以你不必自责！\n\n或许你也发现了，“真的”这两个字出现的次数太多太频繁了，说这么多一是表达出强调作用，二是“真的”想表达出我爱你，是从心里的爱，虽然不如你期望的爱！( t_t)\n\n\n# 爱要向前进\n\n\n\n我记得你也说过，缺点是每个人都有的，而爱情教会则是教会了彼此包容。以后的路还很长，生气吵架拌嘴是少不了的，但是不管发生什么，希望余生，有你陪我度过！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "项目管理 - 工作安排",
      "frontmatter": {
        "title": "项目管理 - 工作安排",
        "date": "2020-11-19T00:00:00.000Z",
        "sidebarDepth": 0,
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20201119.html",
      "relativePath": "views/essay/20201119.md",
      "key": "v-eef8d5fe",
      "path": "/views/essay/20201119.html",
      "headers": [
        {
          "level": 2,
          "title": "任务",
          "slug": "任务",
          "normalizedTitle": "任务",
          "charIndex": 69
        },
        {
          "level": 2,
          "title": "做法",
          "slug": "做法",
          "normalizedTitle": "做法",
          "charIndex": 261
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 269
        }
      ],
      "excerpt": "<Boxx/>\n<p>近期项目中遇到一些管理方面的问题，虽说目前技术开发占多一点，但工作中人际交往必不可少，人只有在心情愉悦的情况下才能更高效的工作。</p>\n",
      "headersStr": "任务 做法 总结",
      "content": "近期项目中遇到一些管理方面的问题，虽说目前技术开发占多一点，但工作中人际交往必不可少，人只有在心情愉悦的情况下才能更高效的工作。\n\n\n# 任务\n\n安排任务，首先是个人对工作量的总体把握程度。毕竟有的人效率高，能在很短时间解决很大问题；有的人效率低，就需要有人催一下，加把劲。\n\n但是切记不要催的次数过多了，你去催他，催的次数多了，他自然烦你，而你又操着这份心，本想着都是将这份工组做好，结果却是典型的双方吃力不讨好！\n\n作为下属，忙的时候压力肯定是有的，但也要体谅领导的难处和工作的需要，做到忙中能稳，稳中有戏。\n\n\n# 做法\n\n拿住性子总结了以下几点，上至领导下至下属皆可参考吧：\n\n 1. 任务拆分：将任务分割化，尽量提前到距目标期限前几天，以保证缓冲时间可以解决其他突发性问题。\n 2. 合理安排：将分割后的几个子任务再以天或时间段为单位进行拆分并合理安排，并不定时检查工作结果。\n 3. 协商处理：双方协商工作安排是否合理，有难度一定要提前说，保证每个人有自己的当天工作任务量，在完成任务的前提下其他时间自由支配，只需保证按时交工即可。\n 4. 勤换位思考，多保持沟通。沟通是非常重要重要重要的。\n\n\n# 总结\n\n\n\n相比较而言，这样安排：时间既合理，双方又省时省力！",
      "normalizedContent": "近期项目中遇到一些管理方面的问题，虽说目前技术开发占多一点，但工作中人际交往必不可少，人只有在心情愉悦的情况下才能更高效的工作。\n\n\n# 任务\n\n安排任务，首先是个人对工作量的总体把握程度。毕竟有的人效率高，能在很短时间解决很大问题；有的人效率低，就需要有人催一下，加把劲。\n\n但是切记不要催的次数过多了，你去催他，催的次数多了，他自然烦你，而你又操着这份心，本想着都是将这份工组做好，结果却是典型的双方吃力不讨好！\n\n作为下属，忙的时候压力肯定是有的，但也要体谅领导的难处和工作的需要，做到忙中能稳，稳中有戏。\n\n\n# 做法\n\n拿住性子总结了以下几点，上至领导下至下属皆可参考吧：\n\n 1. 任务拆分：将任务分割化，尽量提前到距目标期限前几天，以保证缓冲时间可以解决其他突发性问题。\n 2. 合理安排：将分割后的几个子任务再以天或时间段为单位进行拆分并合理安排，并不定时检查工作结果。\n 3. 协商处理：双方协商工作安排是否合理，有难度一定要提前说，保证每个人有自己的当天工作任务量，在完成任务的前提下其他时间自由支配，只需保证按时交工即可。\n 4. 勤换位思考，多保持沟通。沟通是非常重要重要重要的。\n\n\n# 总结\n\n\n\n相比较而言，这样安排：时间既合理，双方又省时省力！",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "ECharts常用图表",
      "frontmatter": {
        "title": "ECharts常用图表",
        "date": "2019-08-03T17:37:25.000Z",
        "tags": [
          "ECharts"
        ],
        "categories": [
          "前端 Front-end"
        ],
        "isShowComments": false
      },
      "regularPath": "/views/frontend/EChartsStudy.html",
      "relativePath": "views/frontend/EChartsStudy.md",
      "key": "v-b6e3a2c6",
      "path": "/views/frontend/EChartsStudy.html",
      "headers": [
        {
          "level": 2,
          "title": "介绍",
          "slug": "介绍",
          "normalizedTitle": "介绍",
          "charIndex": 3
        },
        {
          "level": 2,
          "title": "常用网址",
          "slug": "常用网址",
          "normalizedTitle": "常用网址",
          "charIndex": 9
        },
        {
          "level": 2,
          "title": "图表展示如下",
          "slug": "图表展示如下",
          "normalizedTitle": "图表展示如下",
          "charIndex": 17
        },
        {
          "level": 2,
          "title": "使用服务端返回数据的异步加载和更新",
          "slug": "使用服务端返回数据的异步加载和更新",
          "normalizedTitle": "使用服务端返回数据的异步加载和更新",
          "charIndex": 27
        }
      ],
      "headersStr": "介绍 常用网址 图表展示如下 使用服务端返回数据的异步加载和更新",
      "content": " * 介绍\n * 常用网址\n * 图表展示如下\n * 使用服务端返回数据的异步加载和更新\n\n\n\n\n# 介绍\n\n 1. 把常用的ECharts图表整理一下，方便日后的使用\n\n 2. 图表实例可见：http://zpj80231.gitee.io/echartsstudy/\n\n\n# 常用网址\n\n * 在ECharts官网运行编辑实例：\n   \n   * https://www.echartsjs.com/gallery/editor.html?c=doc-example/getting-started\n\n * EChartsoption中各参数详细配置项：\n   \n   * https://echarts.baidu.com/option.html#grid\n\n\n# 图表展示如下\n\n * 柱+折线图\n\n\n\n * 饼图\n\n\n\n * 迁徙图\n\n\n\n * 接入百度地图\n\n\n\n\n# 使用服务端返回数据的异步加载和更新\n\n详见官网：异步数据加载和更新\n\nfunction method(init的char,option参数,查询条件1,查询条件2,查询条件3){\n\t//ECharts 默认有提供了一个简单的加载动画。只需要调用 showLoading 方法显示。数据加载完成后再调用 hideLoading 方法隐藏加载动画。\n    chart.showLoading({\n\t\ttext: '加载中...'\n\t});\n    \n\t$.ajax({\n\t\ttype:\"POST\",\n\t\tdata:{\"查询条件1\":查询条件1,'查询条件2':查询条件2,'查询条件3':查询条件3},\n        url:\"/zhidinglianjie\",\n        success:function(data){\n           if(data){\n               \t/*注意填入数据的格式：\n               \tseries: [{\n                    // 根据名字对应到相应的系列\n                    name: '销量',\n                    data: [53, 25, 26, 20, 32, 25]\n        \t\t}]*/\n\t\t\t\toption.series[0].data =  data.data\n\t\t\t\toption.series[1].data = data.categories\n\t\t\t\tchart.setOption(option);\n           }else{\n                \n           }\n            //数据加载完成后再调用 hideLoading 方法隐藏加载动画。\n\t\t\tchart.hideLoading();\n        },\n        error:function(jqXHR){\n\t\t\tchart.hideLoading();\n        }\n\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",
      "normalizedContent": " * 介绍\n * 常用网址\n * 图表展示如下\n * 使用服务端返回数据的异步加载和更新\n\n\n\n\n# 介绍\n\n 1. 把常用的echarts图表整理一下，方便日后的使用\n\n 2. 图表实例可见：http://zpj80231.gitee.io/echartsstudy/\n\n\n# 常用网址\n\n * 在echarts官网运行编辑实例：\n   \n   * https://www.echartsjs.com/gallery/editor.html?c=doc-example/getting-started\n\n * echartsoption中各参数详细配置项：\n   \n   * https://echarts.baidu.com/option.html#grid\n\n\n# 图表展示如下\n\n * 柱+折线图\n\n\n\n * 饼图\n\n\n\n * 迁徙图\n\n\n\n * 接入百度地图\n\n\n\n\n# 使用服务端返回数据的异步加载和更新\n\n详见官网：异步数据加载和更新\n\nfunction method(init的char,option参数,查询条件1,查询条件2,查询条件3){\n\t//echarts 默认有提供了一个简单的加载动画。只需要调用 showloading 方法显示。数据加载完成后再调用 hideloading 方法隐藏加载动画。\n    chart.showloading({\n\t\ttext: '加载中...'\n\t});\n    \n\t$.ajax({\n\t\ttype:\"post\",\n\t\tdata:{\"查询条件1\":查询条件1,'查询条件2':查询条件2,'查询条件3':查询条件3},\n        url:\"/zhidinglianjie\",\n        success:function(data){\n           if(data){\n               \t/*注意填入数据的格式：\n               \tseries: [{\n                    // 根据名字对应到相应的系列\n                    name: '销量',\n                    data: [53, 25, 26, 20, 32, 25]\n        \t\t}]*/\n\t\t\t\toption.series[0].data =  data.data\n\t\t\t\toption.series[1].data = data.categories\n\t\t\t\tchart.setoption(option);\n           }else{\n                \n           }\n            //数据加载完成后再调用 hideloading 方法隐藏加载动画。\n\t\t\tchart.hideloading();\n        },\n        error:function(jqxhr){\n\t\t\tchart.hideloading();\n        }\n\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "千万不要把Request传递到异步线程里面！有坑！",
      "frontmatter": {
        "title": "千万不要把Request传递到异步线程里面！有坑！",
        "date": "2023-06-05T00:00:00.000Z",
        "tags": [
          "随笔"
        ],
        "categories": [
          "随笔 Essay"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/essay/20230605.html",
      "relativePath": "views/essay/20230605.md",
      "key": "v-67a514f5",
      "path": "/views/essay/20230605.html",
      "headers": [
        {
          "level": 2,
          "title": "搞个 Demo",
          "slug": "搞个-demo",
          "normalizedTitle": "搞个 demo",
          "charIndex": 531
        },
        {
          "level": 2,
          "title": "探索",
          "slug": "探索",
          "normalizedTitle": "探索",
          "charIndex": 106
        },
        {
          "level": 2,
          "title": "request 的生命周期",
          "slug": "request-的生命周期",
          "normalizedTitle": "request 的生命周期",
          "charIndex": 7461
        },
        {
          "level": 2,
          "title": "正确打开方式",
          "slug": "正确打开方式",
          "normalizedTitle": "正确打开方式",
          "charIndex": 10537
        }
      ],
      "excerpt": "<Boxx/>\n<p>前几天在网上冲浪的时候看到一篇技术文章，讲的是他把一个 request 请求传递到了线程池里面，然后遇到了一个匪夷所思的情况。</p>\n",
      "headersStr": "搞个 Demo 探索 request 的生命周期 正确打开方式",
      "content": "前几天在网上冲浪的时候看到一篇技术文章，讲的是他把一个 request 请求传递到了线程池里面，然后遇到了一个匪夷所思的情况。\n\n真实案例分享，来源于知乎 - why技术。\n\n他写了这篇文章，把自己针对这个问题的探索过程分享了出来：springboot 中如何正确的在异步线程中使用request\n\n文章还是挺不错的，把发现问题和解决问题都写的很明白了。\n\n但是，我觉得把探索问题的部分写的太省略了，导致我看完之后都不知道这个问题的根本原因是什么。\n\n而为什么我会对这篇文章特别感兴趣呢？\n\n因为这个“坑”我记得我刚刚入行没两年的也遇到过，我已经不记得自己当时是怎么解决的了，但是我肯定也没有深入的去研究。\n\n因为那个时候遇到问题，就去网上费尽心思的查，粘一个方案过来看能不能用。\n\n如果不能用的话，心里暗骂一句：小可(S)爱(B)，然后接着找。\n\n直到找到一个可以用的。\n\n至于为什么能用？\n\n管它呢，研究这玩意干啥。\n\n\n\n主要是当时觉得探索这个玩意到进入到源码里面去，一涉及到源码心里就犯怵，所以就敬而远之。\n\n现在不一样了，现在我看到源码我就觉得兴奋，心里想着：多好的素材啊。\n\n既然这次又让我遇到了，所以我决定把几年前的坑填上，盘一盘它。\n\n\n\n\n# 搞个 Demo\n\n由于这个现象太过匪夷所思，所以写文章的那个老哥认为这个是一个 BUG，还在 Spring 的 github 上提了一个 issues：\n\n> https://github.com/spring-projects/spring-framework/issues/28741\n\n这里面他附上了一个可以复现的 Demo，所以我就直接拿来用了。\n\n确实是可以复现，但是其实他提供的这个 Demo 还是有点臃肿，具有一点点的迷惑性，直接给我迷晕了，让我在这上面稍微花了时间。\n\n先给你看一下他的 Demo 是怎么样的。\n\n主要是两个 Controller 接口。\n\n第一个接口是 get 请求类型的 getParams，代码很简单，先放在这里，等下用：\n\n\n\n第二个接口是 post 请求类型的 postTest，就这么几行代码：\n\n@PostMapping(\"/postTest\")\npublic String postTest(HttpServletRequest request) {\n    String age1 = request.getParameter(\"age\");\n    String name1 = request.getParameter(\"name\");\n    System.out.println(\"age1=\" + age1 + \",name1=\" + name1);\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            String age2 = request.getParameter(\"age\");\n            String name2 = request.getParameter(\"name\");\n            System.out.println(\"age2=\" + age2 + \",name2=\" + name2);\n            //模拟业务请求\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            age2 = request.getParameter(\"age\");\n            name2 = request.getParameter(\"name\");\n        }\n    }).start();\n    return \"post success\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n主要是里面启动了一个线程，在线程里面有从 request 里面获取参数的动作。\n\n这个方法访问起来是这样的一个情况：\n\n\n\n从 age2、name2 输出上看，虽然 request 传入到异步线程里面了，但是还是能从里面获取到对应的参数，没有看出来有什么毛病。\n\n但是接下来，匪夷所思的事情就要出现了。\n\n还记得我们前面的 getParams 接口吗？\n\n我再把它拿过来给你看一眼：\n\n\n\n你说，就这个接口，我用下面这个链接去访问，在我的认知里面是完全不可能有任何问题的，对吧？\n\n> http://127.0.0.1:8080/getParams?a=1&b=2\n\n但是，这玩意还真的就打破了我的认知：\n\n\n\n在访问 postTest 方法之后，再次访问 getParams 方法，getParams 方法居然抛出异常了？\n\n抛出的异常是说我调用的时候没有传递 b 这个参数。\n\n但是我的链接里面明明就是有 b=2 的啊？\n\n这玩意上哪里说理去？\n\n\n\n上面就是那位老哥提供的可复现的 Demo 的主要部分。\n\n但是我前面说了，这个 Demo 有点臃肿，具有一点点迷惑性。\n\n首先如果我再加一个输出语句，那么在一个短暂的 sleep 之后， age2 和 name2 就没了：\n\n\n\n虽然还是感觉有点神奇吧，但是也没有刚刚那个操作让我感到震惊。\n\n因为从输出 null 这个结果，我至少可以知道程序在这个地方就出现问题了，把问题的范围限定在了一次请求中。\n\n刚刚那个操作，好家伙，表现出来到情况是这样的：\n\n * 先发起一个 post 请求，看起来是正常的。\n * 然后再发起一个 get 请求，这个 get 请求挂了。\n * 但是这个 get 请求从发起的角度来看找不到任何毛病。\n\n你要基于上面这个情况去分析问题的话，就不好找问题了，毕竟要发起两个毫不相干的请求才能触发问题。\n\n\n\n加入一行输出日志，相当于把问题简化了一点。\n\n但是你看到的是我就加了一行输出日志，实际上等我加这行日志的时候，我拿到这个 Demo 已经过去了好几个小时了。\n\n在这期间我也一直以为必须要按照这个流程来操作，才能复现问题。\n\n所以我才说具有一点点迷惑性。\n\n好，现在不管怎么说吧。\n\n我先把 Demo 简化一点，便于继续分析。我的 Demo 可以简化到这个程度：\n\n@GetMapping(\"/getTest\")\npublic String getTest(HttpServletRequest request) {\n    String age = request.getParameter(\"age\");\n    System.out.println(\"age=\" + age);\n    new Thread(() -> {\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        String age1 = request.getParameter(\"age\");\n        System.out.println(\"age1=\" + age1);\n    }).start();\n    return \"success\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nget 和 post 请求都可以，只是我为了方便选择发起 get 请求。\n\n然后只需要传递一个参数就行，核心步骤是要把 request 传递到异步线程里面去，调用 getParameter 再次获取对应入参。\n\n你可以把上面的代码粘到你本地，把项目跑起来，然后调一次下面这个链接：\n\n> http://127.0.0.1:8080/getTest?age=18\n\n从控制台你可以看到这样的输出：\n\n\n\n到这里就复现了前面说的问题。\n\n但是你別着急，你再次发起调用，你会看到控制台的输出是这样的：\n\n\n\n怎么样，是不是很神奇，很懵逼？\n\n为了让你更加直观的懵逼，我给你上个动图，发起两次调用，主要关注控制台的输出：\n\n\n\n好，现在，你就去泡杯茶，点根烟，慢慢去琢磨，这玩意是不是属于超自然现象。\n\n\n\n\n# 探索\n\n其实我看到这个现象的时候并不是特别的震惊，毕竟写文章这几年，什么稀奇古怪的现象都遇到过。\n\n所以我只是轻蔑一笑，看向了我排查问题的武器库，很快就看到了一个比较趁手的东西：开启 Debug 日志。\n\n如果是以前，对于这种没有抛出异常的问题跟着，由于没有异常堆栈，我肯定是迫不及待的正向的 Debug 跟了一下源码，扎到源码里面去一顿狂翻，左看右看。\n\n但是结果常常是一头扎进去之后，很快就迷失了，搞了好几个小时才从源码里面爬出来，出来的时候基本上一无所获。\n\n但是我现在不会这么猴急了，现在就成熟了很多。遇到这类问题不会先急着去卷源码会先多从日志里面挖掘一点东西出来。\n\n所以我遇到这个问题的第一反应就是调整日志级别到 Debug：\n\n> logging.level.root=debug\n\n观察日志这个小技巧我在之前的文章里面也分享过。\n\n当日志调整到 Debug 级别之后，再次发起两次调用，问题复现，同时把日志拿出来做对比。\n\n两次请求的 Debug 日志整体情况是这样的，左边是第一次请求，右边是第二次请求：\n\n\n\n可以看到第一次请求比第二次请求的日志多。\n\n多说明什么问题？\n\n是不是说明第一次请求调用的方法更多一点？\n\n为什么多一点，到底是哪些方法只调用了一次？\n\n我也不知道，但是我能从 Debug 日志里面梳理出来。\n\n比如下面这个图就是梳理出来的第一次请求多打印的日志：\n\n\n\n很快我就从 Debug 日志里面看到了一个我觉得很可疑的地方：\n\n\n\n> Start processing with input [age=18]\n\n这一行日志，只有第一次请求的时候打印了，从日志表达的意思来看，是处理请求里面的 age=18。\n\n为什么第二次不打印呢？\n\n我也不知道，但是我知道了第一个关键断点打在什么位置了。\n\n全局搜索关键字 “Start processing with input” 可以找到配置文件里面的 “parameters.bytes”。\n\n然后全局搜索 “parameters.bytes”，就能找到是在 Parameters.java 文件里面输出的：\n\n\n\n也就是这个地方：\n\n> org.apache.tomcat.util.http.Parameters#processParameters(byte[], int, int, java.nio.charset.Charset)\n\n\n\n找到第一个断点，就找到了突破口，只要好好的拿捏住，之后的事情就基本上就顺风顺水了。\n\n\n\n首先，重启项目，发起调用，在断点处看调用堆栈：\n\n\n\n接下来的思路是什么？\n\n就是我要从堆栈里面找到一个东西。\n\n你想啊，第一次请求走这个地方，第二次请求就不走这个地方了，所以一定有个类似于这样的逻辑：\n\nif(满足某个条件){\n    走processParameters方法\n}\n\n\n1\n2\n3\n\n\n所以，只需要往回找五个调用栈，我就找到了这一个方法：\n\n> org.apache.catalina.connector.Request#getParameter\n\n\n\n这个时候你看旁边的 parametersParsed 参数是 true，按理来说 true 不应该走进 if 分支呀？\n\n因为这个地方我们是从断点处的堆栈信息往回找，在从 parseParameters 方法到 processParameters 方法之间，肯定有地方修改了 parametersParsed 参数的值为 true。\n\n\n\n这一点，从 parametersParsed 的初始值是 false 也能看出来：\n\n\n\n因此，我决定把第二个断点打在 getParameter 方法中：\n\n\n\n再次重启服务，发起调用，parametersParsed 为 false，开始执行 parseParameters() 方法解析参数：\n\n\n\n而解析参数的目的之一就是把我的 age=18 放到 paramHashValues 这个 Map 容器里面：\n\n> org.apache.tomcat.util.http.Parameters#addParameter\n\n\n\nparseParameters() 方法执行完成之后，接着从前面的 paramHashValues 容器里面把 age 对应的 18 返回回去：\n\n\n\n但是，朋友们，注意上面的图片中有个标号为 ① 的地方：\n\n\n\n这个方法，在 parseParameters 方法里面也会被调用：\n\n> org.apache.tomcat.util.http.Parameters#handleQueryParameters\n\n\n\n好，现在打起精神来听我说。\n\nhandleQueryParameters 方法才是真正解析参数的方法，为了防止重复解析它加入了这样的逻辑：\n\n\n\n\n\ndidQueryParameters 初始为 false，随后被设置为 true。\n\n这个很好理解，入参解析一次就行了，解析的产物一个 Map，后续要拿参数对应的值，从 Map 里面获取即可。\n\n比如我把入参修改为这样：\n\n> http://127.0.0.1:8080/getTest?a=1&b=2&c=3&d=4\n\n那么经过解析之后，这个 Map 就变成了这样：\n\n\n\n经过了前面的这一顿折腾之后，现在找到了解析入参的方法。\n\n那么全文的关键点就在 didQueryParameters 这个参数的变化了。\n\n只有是 false 的时候才会去解析入参。\n\n那么我接下来的排查思路就是观察 didQueryParameters 参数的变化，所以在字段上打上断点，重启项目，继续调试：\n\n\n\n第一次进入这个方法的时候 didQueryParameters 为 false，入参是 age=18：\n\n\n\n而第一次进入这个方法的原因我前面也说了，是因为触发了 parseParameters 的逻辑：\n\n\n\n第二次进入这个方法 didQueryParameters 变为 true 了，不用再次解析：\n\n\n\n那么第二次进入这个方法的原因是什么？\n\n前面也说了，getParameter 方法的第一行就是触发解析的逻辑：\n\n\n\n接下来，断点停在了这个地方：\n\n> org.apache.tomcat.util.http.Parameters#recycle\n\n\n\n方法叫做 recycle，表明是循环再利用，在这里面会把存放参数的 Map 清空，把 didQueryParameters 再次设置为了 false。\n\n而当你用同样的手段去观察 parametersParsed 参数，也就是这个参数的时候：\n\n\n\n会发现它也有一个 recycle 方法：\n\n> org.apache.catalina.connector.Request#recycle\n\n\n\n这个方法上的注释，也有一个特别扎眼的词：reuse。\n\n注释过来是这样的：释放所有的对象引用，并初始化实例变量，为重新使用这个对象做准备。\n\n种种迹象表明 request 在 tomcat 里面是循环使用的。\n\n虽然在这之前我也知道是循环使用的，但是百闻不如一见嘛。这次是我 Debug 的时候亲眼看到了。\n\n又拿捏一个小细节。\n\n\n\n由于我们在异步线程里面还触发了一次 getParameter 方法：\n\n\n\n但是 getTest 方法已经完成了响应，这个时候 Request 可能已经完成了回收。\n\n注意我说的是“可能”，因为这个时候 Request 的回收动作和异步线程谁先谁后还不一定。\n\n这也解释了这个现象：\n\n\n\n虽然 request 传入到异步线程里面了，但是还是能从里面获取到对应的参数。\n\n因为此时 request 的回收动作还没做完，还可以继续获取参数。\n\n为了避免这个“可能”，我把 sleep 的时间调整为 5s，保证 request 完成回收。\n\n然后这异步线程里面继续 Debug，接下来神奇的事情就要开始了。\n\n\n\n再次触发 handleQueryParameters 的时候，didQueryParameters 由于被 recycle 了，所以变成了 false。\n\n然后执行解析的逻辑，把 didQueryParameters 设置为 true。\n\n但是，我们可以看到，此时查询的内容却没有了，是个 null：\n\n\n\n这个也好理解，肯定是随着调用结束，被 recycle 了嘛：\n\n\n\n所以，到这里我能解答为什么异步线程里面的输出是 null 了。\n\nqueryMB 就是我调用的时候传入的 age=18。\n\n通过 Debug 发现异步线程里面调用 getParameter 的时候没有 queryMB ，所以就不会解析出 Map。\n\n没有 Map ，异步线程里面的输出肯定是 null。\n\n为什么没有 queryMB 呢？\n\n因为当前这个请求已经被返回了，执行了 recycle 相关操作，queryMB 就是在这个时候没有的。\n\n那么为什么再次发起调用，会出现这个神奇的现象呢？\n\n\n\n很简单，因为在异步线程里面调用 getParameter 的时候，把 didQueryParameters 设置为 true 了。\n\n但是异步线程里面的调用，超出了 request 的生命周期，所以并不会再次触发 request 的 recycle 相关操作，因此这个 request 拿来复用的时候 didQueryParameters 还是 true。\n\n所以，从 Debug 来看，虽然 queryMB 是有值的，但是没用啊，didQueryParameters 是 true，程序直接 return 了，不会去解析你的入参：\n\n\n\n问题得到解答。\n\n此时，我们再回到最开始的这个方法中：\n\n\n\n你想想为什么这个方法调用的时候出现异常了？\n\n还是一样的道理呀，由于 request 是复用的，虽然你传入了参数 b，但是由于前一个请求在异步线程里面调用了 getParameter 方法，将 didQueryParameters 设置为了 true，导致程序不会去解析我传入的 a=1&b=2。\n\n从调用链接的角度来说，虽然我们调用的是这个链接：\n\n> http://127.0.0.1:8080/getParams?a=1&b=2\n\n但是对于程序来说，它等效于这个链接：\n\n> http://127.0.0.1:8080/getParams\n\n由于入参 b 是 int 类型的，那可不就是会抛出这个异常吗：\n\n\n\n这个异常是说：哥们，你要么把 b 搞成 Integer 类型的，不传值我就给你赋为 null。要么给我传一个值。\n\n你现在用 int 来接受，又不给我值，我这没法处理啊？\n\n我能给你默认赋值一个 0 吗？\n\n肯定不能啊，0 和 null 可不是一个含义，万一你程序出异常了，把锅甩给我怎么办？\n\n算了，我还是抛异常吧，最稳妥了。\n\n所以你看，要是你从这个抛异常的地方去找答案，也许能找到，但是路就走远了一点。\n\n因为这个地方并不是问题的根因。\n\n到这里，你应该清楚这个 BUG 到底是怎么回事了。\n\n\n# request 的生命周期\n\n在探索这个问题的过程中，我也想到了另外一个问题：\n\n> 一个 request 请求的生命周期是怎么样的？\n\n这题我记得几年前我背过，现在我确实有点想不起来了，但是我知道去哪里找答案。\n\nJava Servlet Specification，这是一份规范，答案就藏在这个规范里面：\n\n> https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf\n\n在 3.13 小节里面，关于 request 这个 Object 的生命周期，规范是这样说的：\n\n\n\n这寥寥数语，非常关键，所以我一句句的拆解给你看。\n\n> Each request object is valid only within the scope of a servlet’s service method, or within the scope of a filter’s doFilter method，unless the asynchronous processing is enabled for the component and the startAsync method is invoked on the request object.\n\n一上来就是一个长句，但是根本不要慌。\n\n你知道的，我英语八级半，水平一向是可以的。\n\n\n\n先把长句拆短一点，我可以先只翻译 unless 之前的部分。\n\n前面这部分说：每个 request 对象只在 servlet 的服务方法的范围内有效，或者在过滤器的 doFilter 方法的范围内有效。\n\n接着它来了一个 unless，表示转折，和 but 差不多。\n\n我们主要关注 unless 后面这句：\n\n> the asynchronous processing is enabled for the component and the startAsync method is invoked on the request object.\n\n组件的异步处理功能被启用，并且在 request 上调用了 startAsync 方法。\n\n也就是说，request 的生命周期在遇到异步的时候有点特殊，但是这个异步又不是我前面演示的那种异步。\n\n关于异步，规范中提到了 request 里面有个方法：startAsync。\n\n我去看了一眼，果然是有：\n\n\n\n返回值是一个叫做 AsyncContext 的东西。\n\n但是我先按下不表，接着往下翻译。\n\n> In the case where asynchronous processing occurs, the request object remains valid until complete is invoked on the AsyncContext.\n\n在发生异步处理的情况下，request 对象的生命周期一直会延续到在 AsyncContext 上调用 complete 方法之前。\n\n这里又提到了一个 complete 方法，这个 complete 方法 invoked on the AsyncContext。\n\nAsyncContext 是什么玩意？\n\n不就是 request.startAsync() 方法的返回值吗？\n\n果然在 AsyncContext 里面有个 complete 方法：\n\n\n\n不慌，继续按下不表，一会就回收，接着往下看。\n\n> Containers commonly recycle request objects in order to avoid the performance overhead of request object creation.\n\n容器通常会 recycle 请求对象，以避免创建请求对象的性能开销。\n\n看到这个 recycle 我们就很眼熟了，原来规范里面是建议了容器里面实现 request 的时候尽量复用，而不是回收，目的是节约性能。\n\n这玩意，属于意外收获呀。\n\n最后一句话是这样的：\n\n> The developer must be aware that maintaining references to request objects for which startAsync has not been called outside the scope described above is not recommended as it may have indeterminate results.\n\n这句话是说：程序员朋友们必须要意识到，我不建议在上述范围之外维护 request 的引用，因为它可能会产生不确定的结果。\n\n看到这个“不确定的结果”时我很开心，因为我前面已经演示过了，确实会产生莫名其妙的结果。\n\n但是规范里面在“scope”之前还加了一个限定词：startAsync has not been called。\n\n反过来说，意思就是如果你有一个调用了 startAsync 方法的 request，那么在上述范围之外，你还可以操作这个 request，也不会有问题。\n\n这一整段话中，我们提炼到了两个关键的方法：\n\n * request 的 startAsync 方法\n * AsyncContext 的 complete 方法\n\n根据规范来说，这两个方法才是 request 异步编程的正确打开方式。\n\n\n# 正确打开方式\n\n在这之前，假设你完全不知道 startAsync 和 complete 方法。\n\n但是看了规范上的描述，猜也能猜出来代码应该这样写，然后发起多次调用，没有任何毛病：\n\n\n\n这就是正确的打开方式。\n\n从现象上来说，就是 getTest 请求返回之后，request 线程并没有被调用 recycle 方法进行回收。\n\n为什么这样写就能实现 request 的异步化呢？\n\n用脚指头想也能想到，一定有一个这样的判断逻辑存在：\n\nif(调用过request的startAsync方法){\n    先不回收\n}\n\n\n1\n2\n3\n\n\n所以，用之前的方法，在 recycle 方法上打断点，并往回找，很快就能找到这个方法：\n\n\n\n然后，关于 AsyncContext 的 complete 方法我还注意到它有这样的一个描述：\n\n\n\n也就是说在调用 complete 方法之后 response 流才会关闭，那么有意思的就来了：\n\n\n\n我不仅在异步线程里面可以操作 request 还可以操作 response。\n\n但是转念一想，既然都是异步编程了，操作 response 的意义肯定比操作 request 的意义更大。\n\n关于 Tomcat 对于异步请求的支持还有很多可以探索的地方，自己慢慢去玩吧。\n\n写到这里的时候我发现标题说的也不对，标题是：千万不要把 Request 传递到异步线程里面！有坑！\n\n而正确的说法应该是：\n\n> 千万不要随便把 Request 传递到异步线程里面！有坑！你拿捏不住，得用 startAsync 方法才行。\n\n好了，就这样吧，本文写到这里就差不多了。\n\n本文主要是分享了一下 request 放到异步线程之后的诡异现象和排查方法，最后也给出了正确的打开方式。\n\n希望你能掌握到这样的一个问题排查方法，不要惧怕问题，要抽丝剥茧的干它。\n\n然后，其实和 BUG 排查比起来，关于 request 的异步编程相关的知识更加重要，本文只是做了一个小小的引子，如果这块知识对你是空白的，希望你有兴趣的话自己去研究一下，很有价值。\n\n最后，我想说的是，关于之前文章的一个留言：\n\n\n\n从看到这个现象，到写完这篇文章，我不断的调试程序，至少重启了近百次服务，发起了上百次请求。在源码里面也走了一些弯路，最后才抽丝剥茧的看到本问题的根因。\n\n所以，我排查问题的经验就一个字：\n\n",
      "normalizedContent": "前几天在网上冲浪的时候看到一篇技术文章，讲的是他把一个 request 请求传递到了线程池里面，然后遇到了一个匪夷所思的情况。\n\n真实案例分享，来源于知乎 - why技术。\n\n他写了这篇文章，把自己针对这个问题的探索过程分享了出来：springboot 中如何正确的在异步线程中使用request\n\n文章还是挺不错的，把发现问题和解决问题都写的很明白了。\n\n但是，我觉得把探索问题的部分写的太省略了，导致我看完之后都不知道这个问题的根本原因是什么。\n\n而为什么我会对这篇文章特别感兴趣呢？\n\n因为这个“坑”我记得我刚刚入行没两年的也遇到过，我已经不记得自己当时是怎么解决的了，但是我肯定也没有深入的去研究。\n\n因为那个时候遇到问题，就去网上费尽心思的查，粘一个方案过来看能不能用。\n\n如果不能用的话，心里暗骂一句：小可(s)爱(b)，然后接着找。\n\n直到找到一个可以用的。\n\n至于为什么能用？\n\n管它呢，研究这玩意干啥。\n\n\n\n主要是当时觉得探索这个玩意到进入到源码里面去，一涉及到源码心里就犯怵，所以就敬而远之。\n\n现在不一样了，现在我看到源码我就觉得兴奋，心里想着：多好的素材啊。\n\n既然这次又让我遇到了，所以我决定把几年前的坑填上，盘一盘它。\n\n\n\n\n# 搞个 demo\n\n由于这个现象太过匪夷所思，所以写文章的那个老哥认为这个是一个 bug，还在 spring 的 github 上提了一个 issues：\n\n> https://github.com/spring-projects/spring-framework/issues/28741\n\n这里面他附上了一个可以复现的 demo，所以我就直接拿来用了。\n\n确实是可以复现，但是其实他提供的这个 demo 还是有点臃肿，具有一点点的迷惑性，直接给我迷晕了，让我在这上面稍微花了时间。\n\n先给你看一下他的 demo 是怎么样的。\n\n主要是两个 controller 接口。\n\n第一个接口是 get 请求类型的 getparams，代码很简单，先放在这里，等下用：\n\n\n\n第二个接口是 post 请求类型的 posttest，就这么几行代码：\n\n@postmapping(\"/posttest\")\npublic string posttest(httpservletrequest request) {\n    string age1 = request.getparameter(\"age\");\n    string name1 = request.getparameter(\"name\");\n    system.out.println(\"age1=\" + age1 + \",name1=\" + name1);\n    new thread(new runnable() {\n        @override\n        public void run() {\n            string age2 = request.getparameter(\"age\");\n            string name2 = request.getparameter(\"name\");\n            system.out.println(\"age2=\" + age2 + \",name2=\" + name2);\n            //模拟业务请求\n            try {\n                thread.sleep(200);\n            } catch (interruptedexception e) {\n                throw new runtimeexception(e);\n            }\n            age2 = request.getparameter(\"age\");\n            name2 = request.getparameter(\"name\");\n        }\n    }).start();\n    return \"post success\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n主要是里面启动了一个线程，在线程里面有从 request 里面获取参数的动作。\n\n这个方法访问起来是这样的一个情况：\n\n\n\n从 age2、name2 输出上看，虽然 request 传入到异步线程里面了，但是还是能从里面获取到对应的参数，没有看出来有什么毛病。\n\n但是接下来，匪夷所思的事情就要出现了。\n\n还记得我们前面的 getparams 接口吗？\n\n我再把它拿过来给你看一眼：\n\n\n\n你说，就这个接口，我用下面这个链接去访问，在我的认知里面是完全不可能有任何问题的，对吧？\n\n> http://127.0.0.1:8080/getparams?a=1&b=2\n\n但是，这玩意还真的就打破了我的认知：\n\n\n\n在访问 posttest 方法之后，再次访问 getparams 方法，getparams 方法居然抛出异常了？\n\n抛出的异常是说我调用的时候没有传递 b 这个参数。\n\n但是我的链接里面明明就是有 b=2 的啊？\n\n这玩意上哪里说理去？\n\n\n\n上面就是那位老哥提供的可复现的 demo 的主要部分。\n\n但是我前面说了，这个 demo 有点臃肿，具有一点点迷惑性。\n\n首先如果我再加一个输出语句，那么在一个短暂的 sleep 之后， age2 和 name2 就没了：\n\n\n\n虽然还是感觉有点神奇吧，但是也没有刚刚那个操作让我感到震惊。\n\n因为从输出 null 这个结果，我至少可以知道程序在这个地方就出现问题了，把问题的范围限定在了一次请求中。\n\n刚刚那个操作，好家伙，表现出来到情况是这样的：\n\n * 先发起一个 post 请求，看起来是正常的。\n * 然后再发起一个 get 请求，这个 get 请求挂了。\n * 但是这个 get 请求从发起的角度来看找不到任何毛病。\n\n你要基于上面这个情况去分析问题的话，就不好找问题了，毕竟要发起两个毫不相干的请求才能触发问题。\n\n\n\n加入一行输出日志，相当于把问题简化了一点。\n\n但是你看到的是我就加了一行输出日志，实际上等我加这行日志的时候，我拿到这个 demo 已经过去了好几个小时了。\n\n在这期间我也一直以为必须要按照这个流程来操作，才能复现问题。\n\n所以我才说具有一点点迷惑性。\n\n好，现在不管怎么说吧。\n\n我先把 demo 简化一点，便于继续分析。我的 demo 可以简化到这个程度：\n\n@getmapping(\"/gettest\")\npublic string gettest(httpservletrequest request) {\n    string age = request.getparameter(\"age\");\n    system.out.println(\"age=\" + age);\n    new thread(() -> {\n        try {\n            thread.sleep(200);\n        } catch (interruptedexception e) {\n            throw new runtimeexception(e);\n        }\n        string age1 = request.getparameter(\"age\");\n        system.out.println(\"age1=\" + age1);\n    }).start();\n    return \"success\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nget 和 post 请求都可以，只是我为了方便选择发起 get 请求。\n\n然后只需要传递一个参数就行，核心步骤是要把 request 传递到异步线程里面去，调用 getparameter 再次获取对应入参。\n\n你可以把上面的代码粘到你本地，把项目跑起来，然后调一次下面这个链接：\n\n> http://127.0.0.1:8080/gettest?age=18\n\n从控制台你可以看到这样的输出：\n\n\n\n到这里就复现了前面说的问题。\n\n但是你別着急，你再次发起调用，你会看到控制台的输出是这样的：\n\n\n\n怎么样，是不是很神奇，很懵逼？\n\n为了让你更加直观的懵逼，我给你上个动图，发起两次调用，主要关注控制台的输出：\n\n\n\n好，现在，你就去泡杯茶，点根烟，慢慢去琢磨，这玩意是不是属于超自然现象。\n\n\n\n\n# 探索\n\n其实我看到这个现象的时候并不是特别的震惊，毕竟写文章这几年，什么稀奇古怪的现象都遇到过。\n\n所以我只是轻蔑一笑，看向了我排查问题的武器库，很快就看到了一个比较趁手的东西：开启 debug 日志。\n\n如果是以前，对于这种没有抛出异常的问题跟着，由于没有异常堆栈，我肯定是迫不及待的正向的 debug 跟了一下源码，扎到源码里面去一顿狂翻，左看右看。\n\n但是结果常常是一头扎进去之后，很快就迷失了，搞了好几个小时才从源码里面爬出来，出来的时候基本上一无所获。\n\n但是我现在不会这么猴急了，现在就成熟了很多。遇到这类问题不会先急着去卷源码会先多从日志里面挖掘一点东西出来。\n\n所以我遇到这个问题的第一反应就是调整日志级别到 debug：\n\n> logging.level.root=debug\n\n观察日志这个小技巧我在之前的文章里面也分享过。\n\n当日志调整到 debug 级别之后，再次发起两次调用，问题复现，同时把日志拿出来做对比。\n\n两次请求的 debug 日志整体情况是这样的，左边是第一次请求，右边是第二次请求：\n\n\n\n可以看到第一次请求比第二次请求的日志多。\n\n多说明什么问题？\n\n是不是说明第一次请求调用的方法更多一点？\n\n为什么多一点，到底是哪些方法只调用了一次？\n\n我也不知道，但是我能从 debug 日志里面梳理出来。\n\n比如下面这个图就是梳理出来的第一次请求多打印的日志：\n\n\n\n很快我就从 debug 日志里面看到了一个我觉得很可疑的地方：\n\n\n\n> start processing with input [age=18]\n\n这一行日志，只有第一次请求的时候打印了，从日志表达的意思来看，是处理请求里面的 age=18。\n\n为什么第二次不打印呢？\n\n我也不知道，但是我知道了第一个关键断点打在什么位置了。\n\n全局搜索关键字 “start processing with input” 可以找到配置文件里面的 “parameters.bytes”。\n\n然后全局搜索 “parameters.bytes”，就能找到是在 parameters.java 文件里面输出的：\n\n\n\n也就是这个地方：\n\n> org.apache.tomcat.util.http.parameters#processparameters(byte[], int, int, java.nio.charset.charset)\n\n\n\n找到第一个断点，就找到了突破口，只要好好的拿捏住，之后的事情就基本上就顺风顺水了。\n\n\n\n首先，重启项目，发起调用，在断点处看调用堆栈：\n\n\n\n接下来的思路是什么？\n\n就是我要从堆栈里面找到一个东西。\n\n你想啊，第一次请求走这个地方，第二次请求就不走这个地方了，所以一定有个类似于这样的逻辑：\n\nif(满足某个条件){\n    走processparameters方法\n}\n\n\n1\n2\n3\n\n\n所以，只需要往回找五个调用栈，我就找到了这一个方法：\n\n> org.apache.catalina.connector.request#getparameter\n\n\n\n这个时候你看旁边的 parametersparsed 参数是 true，按理来说 true 不应该走进 if 分支呀？\n\n因为这个地方我们是从断点处的堆栈信息往回找，在从 parseparameters 方法到 processparameters 方法之间，肯定有地方修改了 parametersparsed 参数的值为 true。\n\n\n\n这一点，从 parametersparsed 的初始值是 false 也能看出来：\n\n\n\n因此，我决定把第二个断点打在 getparameter 方法中：\n\n\n\n再次重启服务，发起调用，parametersparsed 为 false，开始执行 parseparameters() 方法解析参数：\n\n\n\n而解析参数的目的之一就是把我的 age=18 放到 paramhashvalues 这个 map 容器里面：\n\n> org.apache.tomcat.util.http.parameters#addparameter\n\n\n\nparseparameters() 方法执行完成之后，接着从前面的 paramhashvalues 容器里面把 age 对应的 18 返回回去：\n\n\n\n但是，朋友们，注意上面的图片中有个标号为 ① 的地方：\n\n\n\n这个方法，在 parseparameters 方法里面也会被调用：\n\n> org.apache.tomcat.util.http.parameters#handlequeryparameters\n\n\n\n好，现在打起精神来听我说。\n\nhandlequeryparameters 方法才是真正解析参数的方法，为了防止重复解析它加入了这样的逻辑：\n\n\n\n\n\ndidqueryparameters 初始为 false，随后被设置为 true。\n\n这个很好理解，入参解析一次就行了，解析的产物一个 map，后续要拿参数对应的值，从 map 里面获取即可。\n\n比如我把入参修改为这样：\n\n> http://127.0.0.1:8080/gettest?a=1&b=2&c=3&d=4\n\n那么经过解析之后，这个 map 就变成了这样：\n\n\n\n经过了前面的这一顿折腾之后，现在找到了解析入参的方法。\n\n那么全文的关键点就在 didqueryparameters 这个参数的变化了。\n\n只有是 false 的时候才会去解析入参。\n\n那么我接下来的排查思路就是观察 didqueryparameters 参数的变化，所以在字段上打上断点，重启项目，继续调试：\n\n\n\n第一次进入这个方法的时候 didqueryparameters 为 false，入参是 age=18：\n\n\n\n而第一次进入这个方法的原因我前面也说了，是因为触发了 parseparameters 的逻辑：\n\n\n\n第二次进入这个方法 didqueryparameters 变为 true 了，不用再次解析：\n\n\n\n那么第二次进入这个方法的原因是什么？\n\n前面也说了，getparameter 方法的第一行就是触发解析的逻辑：\n\n\n\n接下来，断点停在了这个地方：\n\n> org.apache.tomcat.util.http.parameters#recycle\n\n\n\n方法叫做 recycle，表明是循环再利用，在这里面会把存放参数的 map 清空，把 didqueryparameters 再次设置为了 false。\n\n而当你用同样的手段去观察 parametersparsed 参数，也就是这个参数的时候：\n\n\n\n会发现它也有一个 recycle 方法：\n\n> org.apache.catalina.connector.request#recycle\n\n\n\n这个方法上的注释，也有一个特别扎眼的词：reuse。\n\n注释过来是这样的：释放所有的对象引用，并初始化实例变量，为重新使用这个对象做准备。\n\n种种迹象表明 request 在 tomcat 里面是循环使用的。\n\n虽然在这之前我也知道是循环使用的，但是百闻不如一见嘛。这次是我 debug 的时候亲眼看到了。\n\n又拿捏一个小细节。\n\n\n\n由于我们在异步线程里面还触发了一次 getparameter 方法：\n\n\n\n但是 gettest 方法已经完成了响应，这个时候 request 可能已经完成了回收。\n\n注意我说的是“可能”，因为这个时候 request 的回收动作和异步线程谁先谁后还不一定。\n\n这也解释了这个现象：\n\n\n\n虽然 request 传入到异步线程里面了，但是还是能从里面获取到对应的参数。\n\n因为此时 request 的回收动作还没做完，还可以继续获取参数。\n\n为了避免这个“可能”，我把 sleep 的时间调整为 5s，保证 request 完成回收。\n\n然后这异步线程里面继续 debug，接下来神奇的事情就要开始了。\n\n\n\n再次触发 handlequeryparameters 的时候，didqueryparameters 由于被 recycle 了，所以变成了 false。\n\n然后执行解析的逻辑，把 didqueryparameters 设置为 true。\n\n但是，我们可以看到，此时查询的内容却没有了，是个 null：\n\n\n\n这个也好理解，肯定是随着调用结束，被 recycle 了嘛：\n\n\n\n所以，到这里我能解答为什么异步线程里面的输出是 null 了。\n\nquerymb 就是我调用的时候传入的 age=18。\n\n通过 debug 发现异步线程里面调用 getparameter 的时候没有 querymb ，所以就不会解析出 map。\n\n没有 map ，异步线程里面的输出肯定是 null。\n\n为什么没有 querymb 呢？\n\n因为当前这个请求已经被返回了，执行了 recycle 相关操作，querymb 就是在这个时候没有的。\n\n那么为什么再次发起调用，会出现这个神奇的现象呢？\n\n\n\n很简单，因为在异步线程里面调用 getparameter 的时候，把 didqueryparameters 设置为 true 了。\n\n但是异步线程里面的调用，超出了 request 的生命周期，所以并不会再次触发 request 的 recycle 相关操作，因此这个 request 拿来复用的时候 didqueryparameters 还是 true。\n\n所以，从 debug 来看，虽然 querymb 是有值的，但是没用啊，didqueryparameters 是 true，程序直接 return 了，不会去解析你的入参：\n\n\n\n问题得到解答。\n\n此时，我们再回到最开始的这个方法中：\n\n\n\n你想想为什么这个方法调用的时候出现异常了？\n\n还是一样的道理呀，由于 request 是复用的，虽然你传入了参数 b，但是由于前一个请求在异步线程里面调用了 getparameter 方法，将 didqueryparameters 设置为了 true，导致程序不会去解析我传入的 a=1&b=2。\n\n从调用链接的角度来说，虽然我们调用的是这个链接：\n\n> http://127.0.0.1:8080/getparams?a=1&b=2\n\n但是对于程序来说，它等效于这个链接：\n\n> http://127.0.0.1:8080/getparams\n\n由于入参 b 是 int 类型的，那可不就是会抛出这个异常吗：\n\n\n\n这个异常是说：哥们，你要么把 b 搞成 integer 类型的，不传值我就给你赋为 null。要么给我传一个值。\n\n你现在用 int 来接受，又不给我值，我这没法处理啊？\n\n我能给你默认赋值一个 0 吗？\n\n肯定不能啊，0 和 null 可不是一个含义，万一你程序出异常了，把锅甩给我怎么办？\n\n算了，我还是抛异常吧，最稳妥了。\n\n所以你看，要是你从这个抛异常的地方去找答案，也许能找到，但是路就走远了一点。\n\n因为这个地方并不是问题的根因。\n\n到这里，你应该清楚这个 bug 到底是怎么回事了。\n\n\n# request 的生命周期\n\n在探索这个问题的过程中，我也想到了另外一个问题：\n\n> 一个 request 请求的生命周期是怎么样的？\n\n这题我记得几年前我背过，现在我确实有点想不起来了，但是我知道去哪里找答案。\n\njava servlet specification，这是一份规范，答案就藏在这个规范里面：\n\n> https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_final.pdf\n\n在 3.13 小节里面，关于 request 这个 object 的生命周期，规范是这样说的：\n\n\n\n这寥寥数语，非常关键，所以我一句句的拆解给你看。\n\n> each request object is valid only within the scope of a servlet’s service method, or within the scope of a filter’s dofilter method，unless the asynchronous processing is enabled for the component and the startasync method is invoked on the request object.\n\n一上来就是一个长句，但是根本不要慌。\n\n你知道的，我英语八级半，水平一向是可以的。\n\n\n\n先把长句拆短一点，我可以先只翻译 unless 之前的部分。\n\n前面这部分说：每个 request 对象只在 servlet 的服务方法的范围内有效，或者在过滤器的 dofilter 方法的范围内有效。\n\n接着它来了一个 unless，表示转折，和 but 差不多。\n\n我们主要关注 unless 后面这句：\n\n> the asynchronous processing is enabled for the component and the startasync method is invoked on the request object.\n\n组件的异步处理功能被启用，并且在 request 上调用了 startasync 方法。\n\n也就是说，request 的生命周期在遇到异步的时候有点特殊，但是这个异步又不是我前面演示的那种异步。\n\n关于异步，规范中提到了 request 里面有个方法：startasync。\n\n我去看了一眼，果然是有：\n\n\n\n返回值是一个叫做 asynccontext 的东西。\n\n但是我先按下不表，接着往下翻译。\n\n> in the case where asynchronous processing occurs, the request object remains valid until complete is invoked on the asynccontext.\n\n在发生异步处理的情况下，request 对象的生命周期一直会延续到在 asynccontext 上调用 complete 方法之前。\n\n这里又提到了一个 complete 方法，这个 complete 方法 invoked on the asynccontext。\n\nasynccontext 是什么玩意？\n\n不就是 request.startasync() 方法的返回值吗？\n\n果然在 asynccontext 里面有个 complete 方法：\n\n\n\n不慌，继续按下不表，一会就回收，接着往下看。\n\n> containers commonly recycle request objects in order to avoid the performance overhead of request object creation.\n\n容器通常会 recycle 请求对象，以避免创建请求对象的性能开销。\n\n看到这个 recycle 我们就很眼熟了，原来规范里面是建议了容器里面实现 request 的时候尽量复用，而不是回收，目的是节约性能。\n\n这玩意，属于意外收获呀。\n\n最后一句话是这样的：\n\n> the developer must be aware that maintaining references to request objects for which startasync has not been called outside the scope described above is not recommended as it may have indeterminate results.\n\n这句话是说：程序员朋友们必须要意识到，我不建议在上述范围之外维护 request 的引用，因为它可能会产生不确定的结果。\n\n看到这个“不确定的结果”时我很开心，因为我前面已经演示过了，确实会产生莫名其妙的结果。\n\n但是规范里面在“scope”之前还加了一个限定词：startasync has not been called。\n\n反过来说，意思就是如果你有一个调用了 startasync 方法的 request，那么在上述范围之外，你还可以操作这个 request，也不会有问题。\n\n这一整段话中，我们提炼到了两个关键的方法：\n\n * request 的 startasync 方法\n * asynccontext 的 complete 方法\n\n根据规范来说，这两个方法才是 request 异步编程的正确打开方式。\n\n\n# 正确打开方式\n\n在这之前，假设你完全不知道 startasync 和 complete 方法。\n\n但是看了规范上的描述，猜也能猜出来代码应该这样写，然后发起多次调用，没有任何毛病：\n\n\n\n这就是正确的打开方式。\n\n从现象上来说，就是 gettest 请求返回之后，request 线程并没有被调用 recycle 方法进行回收。\n\n为什么这样写就能实现 request 的异步化呢？\n\n用脚指头想也能想到，一定有一个这样的判断逻辑存在：\n\nif(调用过request的startasync方法){\n    先不回收\n}\n\n\n1\n2\n3\n\n\n所以，用之前的方法，在 recycle 方法上打断点，并往回找，很快就能找到这个方法：\n\n\n\n然后，关于 asynccontext 的 complete 方法我还注意到它有这样的一个描述：\n\n\n\n也就是说在调用 complete 方法之后 response 流才会关闭，那么有意思的就来了：\n\n\n\n我不仅在异步线程里面可以操作 request 还可以操作 response。\n\n但是转念一想，既然都是异步编程了，操作 response 的意义肯定比操作 request 的意义更大。\n\n关于 tomcat 对于异步请求的支持还有很多可以探索的地方，自己慢慢去玩吧。\n\n写到这里的时候我发现标题说的也不对，标题是：千万不要把 request 传递到异步线程里面！有坑！\n\n而正确的说法应该是：\n\n> 千万不要随便把 request 传递到异步线程里面！有坑！你拿捏不住，得用 startasync 方法才行。\n\n好了，就这样吧，本文写到这里就差不多了。\n\n本文主要是分享了一下 request 放到异步线程之后的诡异现象和排查方法，最后也给出了正确的打开方式。\n\n希望你能掌握到这样的一个问题排查方法，不要惧怕问题，要抽丝剥茧的干它。\n\n然后，其实和 bug 排查比起来，关于 request 的异步编程相关的知识更加重要，本文只是做了一个小小的引子，如果这块知识对你是空白的，希望你有兴趣的话自己去研究一下，很有价值。\n\n最后，我想说的是，关于之前文章的一个留言：\n\n\n\n从看到这个现象，到写完这篇文章，我不断的调试程序，至少重启了近百次服务，发起了上百次请求。在源码里面也走了一些弯路，最后才抽丝剥茧的看到本问题的根因。\n\n所以，我排查问题的经验就一个字：\n\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2023/06/09, 13:39:24",
      "lastUpdatedTimestamp": 1686289164000
    },
    {
      "title": "vuepress-theme-reco主题开发",
      "frontmatter": {
        "title": "vuepress-theme-reco主题开发",
        "date": "2019-11-14T16:41:12.000Z",
        "sidebar": true,
        "sidebarDepth": 5,
        "tags": [
          "vuepress"
        ],
        "categories": [
          "前端 Front-end"
        ],
        "isShowComments": false
      },
      "regularPath": "/views/frontend/reco-info.html",
      "relativePath": "views/frontend/reco-info.md",
      "key": "v-73f785ae",
      "path": "/views/frontend/reco-info.html",
      "headers": [
        {
          "level": 2,
          "title": "序言",
          "slug": "序言",
          "normalizedTitle": "序言",
          "charIndex": 3
        },
        {
          "level": 2,
          "title": "本地环境搭建",
          "slug": "本地环境搭建",
          "normalizedTitle": "本地环境搭建",
          "charIndex": 9
        },
        {
          "level": 3,
          "title": "1. 去 theme-example ，找个合心意的博客 clone",
          "slug": "_1-去-theme-example-找个合心意的博客-clone",
          "normalizedTitle": "1. 去 theme-example ，找个合心意的博客 clone",
          "charIndex": 21
        },
        {
          "level": 3,
          "title": "2. 把项目下载之后，修改 package.json",
          "slug": "_2-把项目下载之后-修改-package-json",
          "normalizedTitle": "2. 把项目下载之后，修改 package.json",
          "charIndex": 61
        },
        {
          "level": 3,
          "title": "3. 更换主题为本地",
          "slug": "_3-更换主题为本地",
          "normalizedTitle": "3. 更换主题为本地",
          "charIndex": 93
        },
        {
          "level": 2,
          "title": "可能遇到的问题",
          "slug": "可能遇到的问题",
          "normalizedTitle": "可能遇到的问题",
          "charIndex": 107
        },
        {
          "level": 3,
          "title": "1. 插件解析失败问题",
          "slug": "_1-插件解析失败问题",
          "normalizedTitle": "1. 插件解析失败问题",
          "charIndex": 120
        }
      ],
      "headersStr": "序言 本地环境搭建 1. 去 theme-example ，找个合心意的博客 clone 2. 把项目下载之后，修改 package.json 3. 更换主题为本地 可能遇到的问题 1. 插件解析失败问题",
      "content": " * 序言\n * 本地环境搭建\n   * 1. 去 theme-example ，找个合心意的博客 clone\n   * 2. 把项目下载之后，修改 package.json\n   * 3. 更换主题为本地\n * 可能遇到的问题\n   * 1. 插件解析失败问题\n\n\n\n\n# 序言\n\n如果你开始或已经使用 vuepress-theme-reco 搭建了属于自己的个人博客的时候，那么恭喜你，你已经成为我们的一员了。 那么我想以下一定是需要了解的：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n\n# 本地环境搭建\n\n\n# 1. 去 theme-example ，找个合心意的博客 clone\n\n * 我就以我的下载我的为例：git clone https://github.com/zpj80231/znote.git\n\n\n# 2. 把项目下载之后，修改 package.json\n\n{\n    \"scripts\": {\n        \"docs:dev\": \"vuepress dev docs\",\n        \"docs:build\": \"vuepress build docs\",\n        \"deploy\": \"bash deploy.sh\"\n    },\n    \"devDependencies\": {\n        \"vuepress\": \"^1.2.0\",\n        \"vuepress-theme-reco\": \"^1.1.2-alpha.2\"        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在此目录下打开命令窗口执行：npm install（提前安装好node.js环境）\n\n\n# 3. 更换主题为本地\n\n * 打开git，克隆：git clone https://github.com/vuepress-reco/vuepress-theme-reco.git\n   \n   把下载下来的文件夹更名为 theme，粘贴至 .vuepress下即可。\n\n * 将主题文件放到本地开发环境\n\n##复制node_modules/vuepress-theme-reco 文件夹\n##粘贴至.vuepress/ 下并更名为theme\nDev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles // 样式\n│   │    │   ├── util // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopModule.js // 依赖注入\n│   │    │   ├── package.json // 主题依赖\n│   │    │   ├── README.md // 主题说明\n│   │    └── config.js\n│   ├── FAQ     // 求索模块\n│   ├── Store   // 仓库模块\n│   ├── Thought // 随笔模块\n│   └── README.md   // 博客首页\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 运行预览\n   \n   执行命令：vuepress dev docs\n   \n   当看到控制台输出：tip Apply theme located at ... 并正常启动，则表示本地环境搭建成功。\n   \n   在浏览器地址输入：http://localhost:8080即可看到界面：\n   \n   \n\n * 如果想直接使用 .html文件的话将 .html文件放在 .vuepress/public 目录下即可（需自己配置引用路径）。\n\n\n# 可能遇到的问题\n\n\n# 1. 插件解析失败问题\n\n> 有这几个解决办法，就是无法解析node_modules依赖关系\n\n * 根目录下安装一下vuepress-theme-reco这个依赖\n * 最直接的就是在主题目录执行一下npm install\n * 或许你删除node_modules，重新安装一下依赖也有可能解决\n * 如以上三步都不行的话，以这个命令npm run docs:dev启动项目，或者联系我",
      "normalizedContent": " * 序言\n * 本地环境搭建\n   * 1. 去 theme-example ，找个合心意的博客 clone\n   * 2. 把项目下载之后，修改 package.json\n   * 3. 更换主题为本地\n * 可能遇到的问题\n   * 1. 插件解析失败问题\n\n\n\n\n# 序言\n\n如果你开始或已经使用 vuepress-theme-reco 搭建了属于自己的个人博客的时候，那么恭喜你，你已经成为我们的一员了。 那么我想以下一定是需要了解的：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n\n# 本地环境搭建\n\n\n# 1. 去 theme-example ，找个合心意的博客 clone\n\n * 我就以我的下载我的为例：git clone https://github.com/zpj80231/znote.git\n\n\n# 2. 把项目下载之后，修改 package.json\n\n{\n    \"scripts\": {\n        \"docs:dev\": \"vuepress dev docs\",\n        \"docs:build\": \"vuepress build docs\",\n        \"deploy\": \"bash deploy.sh\"\n    },\n    \"devdependencies\": {\n        \"vuepress\": \"^1.2.0\",\n        \"vuepress-theme-reco\": \"^1.1.2-alpha.2\"        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在此目录下打开命令窗口执行：npm install（提前安装好node.js环境）\n\n\n# 3. 更换主题为本地\n\n * 打开git，克隆：git clone https://github.com/vuepress-reco/vuepress-theme-reco.git\n   \n   把下载下来的文件夹更名为 theme，粘贴至 .vuepress下即可。\n\n * 将主题文件放到本地开发环境\n\n##复制node_modules/vuepress-theme-reco 文件夹\n##粘贴至.vuepress/ 下并更名为theme\ndev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles // 样式\n│   │    │   ├── util // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopmodule.js // 依赖注入\n│   │    │   ├── package.json // 主题依赖\n│   │    │   ├── readme.md // 主题说明\n│   │    └── config.js\n│   ├── faq     // 求索模块\n│   ├── store   // 仓库模块\n│   ├── thought // 随笔模块\n│   └── readme.md   // 博客首页\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 运行预览\n   \n   执行命令：vuepress dev docs\n   \n   当看到控制台输出：tip apply theme located at ... 并正常启动，则表示本地环境搭建成功。\n   \n   在浏览器地址输入：http://localhost:8080即可看到界面：\n   \n   \n\n * 如果想直接使用 .html文件的话将 .html文件放在 .vuepress/public 目录下即可（需自己配置引用路径）。\n\n\n# 可能遇到的问题\n\n\n# 1. 插件解析失败问题\n\n> 有这几个解决办法，就是无法解析node_modules依赖关系\n\n * 根目录下安装一下vuepress-theme-reco这个依赖\n * 最直接的就是在主题目录执行一下npm install\n * 或许你删除node_modules，重新安装一下依赖也有可能解决\n * 如以上三步都不行的话，以这个命令npm run docs:dev启动项目，或者联系我",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "viaStart",
      "frontmatter": {
        "title": "viaStart",
        "date": "2018-04-23T15:31:26.000Z",
        "tags": [
          "Via"
        ],
        "categories": [
          "前端 Front-end"
        ],
        "isShowComments": false
      },
      "regularPath": "/views/frontend/viaStart.html",
      "relativePath": "views/frontend/viaStart.md",
      "key": "v-4bce123d",
      "path": "/views/frontend/viaStart.html",
      "headers": [
        {
          "level": 2,
          "title": "via或其他浏览器的必选首页",
          "slug": "via或其他浏览器的必选首页",
          "normalizedTitle": "via或其他浏览器的必选首页",
          "charIndex": 3
        },
        {
          "level": 2,
          "title": "简介",
          "slug": "简介",
          "normalizedTitle": "简介",
          "charIndex": 21
        },
        {
          "level": 2,
          "title": "如何使用",
          "slug": "如何使用",
          "normalizedTitle": "如何使用",
          "charIndex": 27
        },
        {
          "level": 2,
          "title": "首页如下",
          "slug": "首页如下",
          "normalizedTitle": "首页如下",
          "charIndex": 35
        }
      ],
      "headersStr": "via或其他浏览器的必选首页 简介 如何使用 首页如下",
      "content": " * via或其他浏览器的必选首页\n * 简介\n * 如何使用\n * 首页如下\n\n\n\n\n# via或其他浏览器的必选首页\n\n\n# 简介\n\n * 现在的手机浏览器样式百出，功能臃肿且复杂\n * 作为极客爱好者，我只需要一个简单的浏览器，so，手机用的 Chrome + Via\n * 但Via浏览器都需要自定义，所以搞了这个HomePage来为Via增加点人性化体验\n\n\n# 如何使用\n\n * 打开via手机浏览器，找到设置\n\n * 进入设置后，找到为浏览器设置主页的地方\n\n * 点击设定主页为特定网页，输入如下地址即可：\n   \n   > http://zpj80231.gitee.io/viastart\n\n * 如果你喜欢的话还可以为你自己的浏览器（手机电脑都OK哟）设置为这个主页！o(￣▽￣)ブ\n\n\n# 首页如下\n\n",
      "normalizedContent": " * via或其他浏览器的必选首页\n * 简介\n * 如何使用\n * 首页如下\n\n\n\n\n# via或其他浏览器的必选首页\n\n\n# 简介\n\n * 现在的手机浏览器样式百出，功能臃肿且复杂\n * 作为极客爱好者，我只需要一个简单的浏览器，so，手机用的 chrome + via\n * 但via浏览器都需要自定义，所以搞了这个homepage来为via增加点人性化体验\n\n\n# 如何使用\n\n * 打开via手机浏览器，找到设置\n\n * 进入设置后，找到为浏览器设置主页的地方\n\n * 点击设定主页为特定网页，输入如下地址即可：\n   \n   > http://zpj80231.gitee.io/viastart\n\n * 如果你喜欢的话还可以为你自己的浏览器（手机电脑都ok哟）设置为这个主页！o(￣▽￣)ブ\n\n\n# 首页如下\n\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "JavaScript中JSON对象和串的互转",
      "frontmatter": {
        "title": "JavaScript中JSON对象和串的互转",
        "date": "2019-03-23T00:00:00.000Z",
        "tags": [
          "JavaScript",
          "json"
        ],
        "categories": [
          "前端 Front-end"
        ],
        "isShowComments": false
      },
      "regularPath": "/views/frontend/js-json.html",
      "relativePath": "views/frontend/js-json.md",
      "key": "v-5e66af89",
      "path": "/views/frontend/js-json.html",
      "headers": [
        {
          "level": 2,
          "title": "JavaScript中的JSON",
          "slug": "javascript中的json",
          "normalizedTitle": "javascript中的json",
          "charIndex": 3
        },
        {
          "level": 2,
          "title": "JSON互转的第二种用法",
          "slug": "json互转的第二种用法",
          "normalizedTitle": "json互转的第二种用法",
          "charIndex": 23
        },
        {
          "level": 2,
          "title": "写给自己的js规范",
          "slug": "写给自己的js规范",
          "normalizedTitle": "写给自己的js规范",
          "charIndex": 39
        },
        {
          "level": 4,
          "title": "在js中书写代码给自己定的规范：（或者objet转string之前）",
          "slug": "在js中书写代码给自己定的规范-或者objet转string之前",
          "normalizedTitle": "在js中书写代码给自己定的规范：（或者objet转string之前）",
          "charIndex": 1444
        },
        {
          "level": 4,
          "title": "在js中书写代码给自己定的规范：（或者string转object之前）",
          "slug": "在js中书写代码给自己定的规范-或者string转object之前",
          "normalizedTitle": "在js中书写代码给自己定的规范：（或者string转object之前）",
          "charIndex": 1618
        },
        {
          "level": 2,
          "title": "其它",
          "slug": "其它",
          "normalizedTitle": "其它",
          "charIndex": 52
        }
      ],
      "headersStr": "JavaScript中的JSON JSON互转的第二种用法 写给自己的js规范 在js中书写代码给自己定的规范：（或者objet转string之前） 在js中书写代码给自己定的规范：（或者string转object之前） 其它",
      "content": " * JavaScript中的JSON\n * JSON互转的第二种用法\n * 写给自己的js规范\n * 其它\n\n\n\n\n# JavaScript中的JSON\n\n> 在实际工作中，我么最常用的就是简单的 JSON.parse(str) 和 JSON.stringify (obj) 做JSON对象和字符串之间的相互转换\n\n * JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象\n * JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串\n\n> 上面那种JSON.parse(string)用法只能转普通对象，当对象中有function事件的时候会自动过滤掉。如下：\n\nvar json={\n  name:'json',\n  getName:function(){\n     return this.name;   \n  }\n}\n\nconsole.log(JSON.stringify(json));\n//\"{\"name\":\"json\"}\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这就坑了，因为需要，必须要得把function也转了才行，怎么办呢？其实大家都没注意到 JSON.stringify还有些参数\n\n\n# JSON互转的第二种用法\n\n * 从Object转为String\n\n  var json={\n    name:'json',\n    getName:function(){\n       return this.name;   \n    }\n  }\n  \n  var s=JSON.stringify(json, function(key, val) {\n    if (typeof val === 'function') {\n      return val + '';\n    }\n    return val;\n  });\n  \n  console.log(s);\n  //\"{\"name\":\"json\",\"getName\":\"function (){\\n     return this.name;   \\n  }\"}\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意转换完成之后记得把 \\n 全部删掉，不然从string再转为object的时候会报错，没错，就是这么坑。\n\n不信的话可以去这么网址试一下：传送们\n\n * 从String转为Object\n\nvar s=`{\"name\":\"json\",\"getName\":\"function (){     return this.name;     }\"}`;\n\nvar o = JSON.parse(s,function(k,v){\n  if(v.indexOf&&v.indexOf('function')>-1){\n     return eval(\"(function(){return \"+v+\" })()\")\n  }\n  return v;\n});\n\nconsole.log(o);//就是原对象啦\n//{ name: \"json\", getName: function (){     return this.name;     } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 写给自己的js规范\n\n# 在js中书写代码给自己定的规范：（或者objet转string之前）\n\n 1. 在js中能用的话 一定要用单引号\n 2. 在使用 if(){}else{} 的时候，一定不要省略大括号\n 3. js中一段代码结束后一定要加 ;（虽然在js中不加不会报错，把对象转为串的时候也不会报错，但是json从串转为对象的时候就会报错了，亲身经历啊！！）\n\n# 在js中书写代码给自己定的规范：（或者string转object之前）\n\n 1. 把所有的 \\r\\n 删掉\n 2. 把所有的 \\t 删掉\n 3. 把所有的 function 中的注释都删掉\n 4. 注意有没有代码不规范的地方（如上规范）\n\n\n# 其它\n\n * JSON转换简单使用\n * JSON转换的第二个参数\n * 在线写js尝试JSON转换",
      "normalizedContent": " * javascript中的json\n * json互转的第二种用法\n * 写给自己的js规范\n * 其它\n\n\n\n\n# javascript中的json\n\n> 在实际工作中，我么最常用的就是简单的 json.parse(str) 和 json.stringify (obj) 做json对象和字符串之间的相互转换\n\n * json.parse(string) ：接受一个 json 字符串并将其转换成一个 javascript 对象\n * json.stringify(obj) ：接受一个 javascript 对象并将其转换为一个 json 字符串\n\n> 上面那种json.parse(string)用法只能转普通对象，当对象中有function事件的时候会自动过滤掉。如下：\n\nvar json={\n  name:'json',\n  getname:function(){\n     return this.name;   \n  }\n}\n\nconsole.log(json.stringify(json));\n//\"{\"name\":\"json\"}\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这就坑了，因为需要，必须要得把function也转了才行，怎么办呢？其实大家都没注意到 json.stringify还有些参数\n\n\n# json互转的第二种用法\n\n * 从object转为string\n\n  var json={\n    name:'json',\n    getname:function(){\n       return this.name;   \n    }\n  }\n  \n  var s=json.stringify(json, function(key, val) {\n    if (typeof val === 'function') {\n      return val + '';\n    }\n    return val;\n  });\n  \n  console.log(s);\n  //\"{\"name\":\"json\",\"getname\":\"function (){\\n     return this.name;   \\n  }\"}\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意转换完成之后记得把 \\n 全部删掉，不然从string再转为object的时候会报错，没错，就是这么坑。\n\n不信的话可以去这么网址试一下：传送们\n\n * 从string转为object\n\nvar s=`{\"name\":\"json\",\"getname\":\"function (){     return this.name;     }\"}`;\n\nvar o = json.parse(s,function(k,v){\n  if(v.indexof&&v.indexof('function')>-1){\n     return eval(\"(function(){return \"+v+\" })()\")\n  }\n  return v;\n});\n\nconsole.log(o);//就是原对象啦\n//{ name: \"json\", getname: function (){     return this.name;     } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 写给自己的js规范\n\n# 在js中书写代码给自己定的规范：（或者objet转string之前）\n\n 1. 在js中能用的话 一定要用单引号\n 2. 在使用 if(){}else{} 的时候，一定不要省略大括号\n 3. js中一段代码结束后一定要加 ;（虽然在js中不加不会报错，把对象转为串的时候也不会报错，但是json从串转为对象的时候就会报错了，亲身经历啊！！）\n\n# 在js中书写代码给自己定的规范：（或者string转object之前）\n\n 1. 把所有的 \\r\\n 删掉\n 2. 把所有的 \\t 删掉\n 3. 把所有的 function 中的注释都删掉\n 4. 注意有没有代码不规范的地方（如上规范）\n\n\n# 其它\n\n * json转换简单使用\n * json转换的第二个参数\n * 在线写js尝试json转换",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "关于Vue的学习",
      "frontmatter": {
        "title": "关于Vue的学习",
        "catalog": true,
        "date": "2019-05-12T13:59:44.000Z",
        "tags": [
          "Vue"
        ],
        "categories": [
          "前端 Front-end"
        ],
        "isShowComments": false
      },
      "regularPath": "/views/frontend/vue-demo.html",
      "relativePath": "views/frontend/vue-demo.md",
      "key": "v-8bea6006",
      "path": "/views/frontend/vue-demo.html",
      "headers": [
        {
          "level": 2,
          "title": "Vue-Demo",
          "slug": "vue-demo",
          "normalizedTitle": "vue-demo",
          "charIndex": 3
        },
        {
          "level": 2,
          "title": "主要完成的功能",
          "slug": "主要完成的功能",
          "normalizedTitle": "主要完成的功能",
          "charIndex": 15
        },
        {
          "level": 2,
          "title": "图形界面展示",
          "slug": "图形界面展示",
          "normalizedTitle": "图形界面展示",
          "charIndex": 26
        },
        {
          "level": 2,
          "title": "感谢",
          "slug": "感谢",
          "normalizedTitle": "感谢",
          "charIndex": 36
        }
      ],
      "headersStr": "Vue-Demo 主要完成的功能 图形界面展示 感谢",
      "content": " * Vue-Demo\n * 主要完成的功能\n * 图形界面展示\n * 感谢\n\n\n\n\n# Vue-Demo\n\n * 这是在学习Vue的同时，写的一个demo\n\n * 项目地址：https://github.com/zpj80231/vue-demo\n   \n   > 点击右上角克隆或下载 下载完成之后，在vue-demo文件目录打开命令窗口 输入命令： npm install （需提前装好node.js环境，如果没有请自行百度） 待npm安装完成之后输入： npm run dev 即可在浏览器看到窗口界面\n\n\n# 主要完成的功能\n\n * 新闻资讯\n   * 新闻资讯列表\n   * 新闻资讯列表详情\n   * 新闻评论功能\n * 图片分享\n   * 图片列表\n   * 图片缩略图功能\n * 商品购买\n   * 经典商品列表布局\n   * 商品详情页面\n   * 添加购物车\n * 购物车（难点）\n\n\n# 图形界面展示\n\n\n# 感谢\n\n * bilibili: vue教程-黑马-205集完整版\n\n * bilibili: hulala赵四(我用的是他的接口)\n\n> http://www.liulongbin.top:3005\n\n * bilibili: 有点小岁\n\n> 服务器：https://github.com/arm-liang/vue-mobbile-server\n> \n> 客户端：https://github.com/arm-liang/vue-mobbile-learning\n> \n> 项目服务器接口： http://120.77.181.41:3000，具体API 接口看GITHUB\n> \n> 项目演示： http://120.77.181.41/vue-learn/",
      "normalizedContent": " * vue-demo\n * 主要完成的功能\n * 图形界面展示\n * 感谢\n\n\n\n\n# vue-demo\n\n * 这是在学习vue的同时，写的一个demo\n\n * 项目地址：https://github.com/zpj80231/vue-demo\n   \n   > 点击右上角克隆或下载 下载完成之后，在vue-demo文件目录打开命令窗口 输入命令： npm install （需提前装好node.js环境，如果没有请自行百度） 待npm安装完成之后输入： npm run dev 即可在浏览器看到窗口界面\n\n\n# 主要完成的功能\n\n * 新闻资讯\n   * 新闻资讯列表\n   * 新闻资讯列表详情\n   * 新闻评论功能\n * 图片分享\n   * 图片列表\n   * 图片缩略图功能\n * 商品购买\n   * 经典商品列表布局\n   * 商品详情页面\n   * 添加购物车\n * 购物车（难点）\n\n\n# 图形界面展示\n\n\n# 感谢\n\n * bilibili: vue教程-黑马-205集完整版\n\n * bilibili: hulala赵四(我用的是他的接口)\n\n> http://www.liulongbin.top:3005\n\n * bilibili: 有点小岁\n\n> 服务器：https://github.com/arm-liang/vue-mobbile-server\n> \n> 客户端：https://github.com/arm-liang/vue-mobbile-learning\n> \n> 项目服务器接口： http://120.77.181.41:3000，具体api 接口看github\n> \n> 项目演示： http://120.77.181.41/vue-learn/",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "title": "vuepress插件：<Boxx/>",
      "frontmatter": {
        "title": "vuepress插件：`<Boxx/>`",
        "date": "2019-11-17T15:53:26.000Z",
        "tags": [
          "vuepress"
        ],
        "categories": [
          "前端 Front-end"
        ],
        "isShowComments": false
      },
      "regularPath": "/views/frontend/vuepress-plugin-boxx.html",
      "relativePath": "views/frontend/vuepress-plugin-boxx.md",
      "key": "v-bb051ac6",
      "path": "/views/frontend/vuepress-plugin-boxx.html",
      "headers": [
        {
          "level": 2,
          "title": "序言",
          "slug": "序言",
          "normalizedTitle": "序言",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "安装",
          "slug": "安装",
          "normalizedTitle": "安装",
          "charIndex": 131
        },
        {
          "level": 2,
          "title": "使用",
          "slug": "使用",
          "normalizedTitle": "使用",
          "charIndex": 63
        },
        {
          "level": 2,
          "title": "默认样式",
          "slug": "默认样式",
          "normalizedTitle": "默认样式",
          "charIndex": 569
        },
        {
          "level": 2,
          "title": "自定义标题和内容",
          "slug": "自定义标题和内容",
          "normalizedTitle": "自定义标题和内容",
          "charIndex": 578
        },
        {
          "level": 2,
          "title": "自定义样式",
          "slug": "自定义样式",
          "normalizedTitle": "自定义样式",
          "charIndex": 786
        }
      ],
      "headersStr": "序言 安装 使用 默认样式 自定义标题和内容 自定义样式",
      "content": "# 序言\n\n * 由于在引入默认的VuePress Custom Containers太过笨重了，故闲来无事对其做一层封装简化使用\n * Github地址：https://github.com/zpj80231/vuepress-plugin-boxx\n\n\n# 安装\n\n * 在文件package.json中的devDependencies下加入\"vuepress-plugin-boxx\": \"0.0.7\"：\n\n\"devDependencies\": {\n    \"vuepress-plugin-boxx\": \"0.0.7\"\n}\n\n\n1\n2\n3\n\n * 在 vuepress 的config.js中配置plugins：\n\nplugins: [\n    [\"vuepress-plugin-boxx\"]\n],\n\n\n1\n2\n3\n\n * 在package.json目录下执行命令：npm install\n * 正常启动项目，接着如下使用即可\n\n\n# 使用\n\n * 引入：只需在你想要插入的地方加入 <Boxx/> 即可（如顶部所示）\n * 内容：默认随机展示名人名句，支持自定义\n * 样式：有三种样式，默认为 tip 样式，支持自定义\n * 注意：除<Boxx/>这个标签是必须外，标签属性均为可选，所有标签属性会在下文中详细介绍\n\n\n# 默认样式\n\n\n# 自定义标题和内容\n\n * 如果默认的名人名句不满足需求的话，自定义只需指定两个属性title和content的值\n\nNAME      TYPE     DESCRIPTION\ntitle     String   要展示的title的内容，支持html标签\ncontent   String   要展示的content的内容，支持html标签\n\n * 当然你也可以只输入title或content，如下：\n\n\n# 自定义样式\n\n * 可以通过以下几个属性实现\n\nNAME           TYPE     DESCRIPTION\nblockStyle     Object   整体块元素的样式\ntitleStyle     Object   只针对title的样式\ncontentStyle   Object   只针对content的样式\nchangeTime     Number   以毫秒值为单位的动态变化时间，顶部为例\n\n需要注意的是：属性值传输的对象只能通过v-bind:绑定来实现\n\n * 以下是对如上样式的示例，在Markdown中这样书写即可：\n\n<marquee>\n<Boxx :blockStyle=\"blockStyle\"  />\n<Boxx type=\"warning\" :blockStyle=\"titleStyle\" :titleStyle=\"titleStyle\" changeTime=\"1000\" title=\"我是一个大大的且变化的 title\"/>\n<Boxx type=\"danger\" :blockStyle=\"contentStyle\" :contentStyle=\"contentStyle\" content=\"我是一个小小的<br><marquee>content</marquee>\"/>\n</marquee>\n\n<script>\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tblockStyle: {'background':'#eee','color':'red'},\n                titleStyle: {'margin-right': '10%','font-size':'16px'},\n                contentStyle: {'margin-right': '20%','font-size':'10px',\n                               \"margin-top\": \"1rem\",\"margin-bottom\": \"0.4rem\"},\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",
      "normalizedContent": "# 序言\n\n * 由于在引入默认的vuepress custom containers太过笨重了，故闲来无事对其做一层封装简化使用\n * github地址：https://github.com/zpj80231/vuepress-plugin-boxx\n\n\n# 安装\n\n * 在文件package.json中的devdependencies下加入\"vuepress-plugin-boxx\": \"0.0.7\"：\n\n\"devdependencies\": {\n    \"vuepress-plugin-boxx\": \"0.0.7\"\n}\n\n\n1\n2\n3\n\n * 在 vuepress 的config.js中配置plugins：\n\nplugins: [\n    [\"vuepress-plugin-boxx\"]\n],\n\n\n1\n2\n3\n\n * 在package.json目录下执行命令：npm install\n * 正常启动项目，接着如下使用即可\n\n\n# 使用\n\n * 引入：只需在你想要插入的地方加入 <boxx/> 即可（如顶部所示）\n * 内容：默认随机展示名人名句，支持自定义\n * 样式：有三种样式，默认为 tip 样式，支持自定义\n * 注意：除<boxx/>这个标签是必须外，标签属性均为可选，所有标签属性会在下文中详细介绍\n\n\n# 默认样式\n\n\n# 自定义标题和内容\n\n * 如果默认的名人名句不满足需求的话，自定义只需指定两个属性title和content的值\n\nname      type     description\ntitle     string   要展示的title的内容，支持html标签\ncontent   string   要展示的content的内容，支持html标签\n\n * 当然你也可以只输入title或content，如下：\n\n\n# 自定义样式\n\n * 可以通过以下几个属性实现\n\nname           type     description\nblockstyle     object   整体块元素的样式\ntitlestyle     object   只针对title的样式\ncontentstyle   object   只针对content的样式\nchangetime     number   以毫秒值为单位的动态变化时间，顶部为例\n\n需要注意的是：属性值传输的对象只能通过v-bind:绑定来实现\n\n * 以下是对如上样式的示例，在markdown中这样书写即可：\n\n<marquee>\n<boxx :blockstyle=\"blockstyle\"  />\n<boxx type=\"warning\" :blockstyle=\"titlestyle\" :titlestyle=\"titlestyle\" changetime=\"1000\" title=\"我是一个大大的且变化的 title\"/>\n<boxx type=\"danger\" :blockstyle=\"contentstyle\" :contentstyle=\"contentstyle\" content=\"我是一个小小的<br><marquee>content</marquee>\"/>\n</marquee>\n\n<script>\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tblockstyle: {'background':'#eee','color':'red'},\n                titlestyle: {'margin-right': '10%','font-size':'16px'},\n                contentstyle: {'margin-right': '20%','font-size':'10px',\n                               \"margin-top\": \"1rem\",\"margin-bottom\": \"0.4rem\"},\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/04/18, 16:11:23",
      "lastUpdatedTimestamp": 1650269483000
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroImageStyle": {
          "maxWidth": "680px",
          "width": "100%",
          "display": "block",
          "margin": "14% auto -16% auto",
          "//border": "1px dashed #000",
          "box-shadow": "8px 8px 20px #022",
          "borderRadius": "10px"
        },
        "isShowTitleInHome": true,
        "actionText": "开启进阶之路",
        "actionLink": "/views/",
        "features": [
          {
            "title": null,
            "details": "把所有的不快给昨天"
          },
          {
            "title": null,
            "details": "把所有的努力给今天"
          },
          {
            "title": null,
            "details": "把所有的希望给明天"
          }
        ]
      },
      "regularPath": "/",
      "relativePath": "README.md",
      "key": "v-13e039be",
      "path": "/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/04/12, 10:22:39",
      "lastUpdatedTimestamp": 1649730159000
    },
    {
      "title": "关于我",
      "frontmatter": {
        "title": "关于我",
        "isTimeLine": false,
        "sidebar": false,
        "isShowComments": false
      },
      "regularPath": "/about/",
      "relativePath": "about/README.md",
      "key": "v-835a9522",
      "path": "/about/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2023/05/04, 15:32:50",
      "lastUpdatedTimestamp": 1683185570000
    },
    {
      "title": "TCP,UDP,HTTP的认识",
      "frontmatter": {
        "title": "TCP,UDP,HTTP的认识",
        "date": "2018-01-16T00:00:00.000Z",
        "tags": [
          "网络协议"
        ],
        "categories": [
          "前端 Front-end",
          "规范 Standard"
        ],
        "isShowComments": true
      },
      "regularPath": "/views/frontend/TCP&UDP.html",
      "relativePath": "views/frontend/TCP&UDP.md",
      "key": "v-607e192e",
      "path": "/views/frontend/TCP&UDP.html",
      "headers": [
        {
          "level": 2,
          "title": "TCP",
          "slug": "tcp",
          "normalizedTitle": "tcp",
          "charIndex": 0
        },
        {
          "level": 3,
          "title": "TCP三次握手 ★",
          "slug": "tcp三次握手-★",
          "normalizedTitle": "tcp三次握手 ★",
          "charIndex": 70
        },
        {
          "level": 3,
          "title": "为什么TCP客户端最后还要发送一次确认呢？",
          "slug": "为什么tcp客户端最后还要发送一次确认呢",
          "normalizedTitle": "为什么tcp客户端最后还要发送一次确认呢？",
          "charIndex": 85
        },
        {
          "level": 2,
          "title": "UDP",
          "slug": "udp",
          "normalizedTitle": "udp",
          "charIndex": 4
        },
        {
          "level": 2,
          "title": "TCP和UDP区别",
          "slug": "tcp和udp区别",
          "normalizedTitle": "tcp和udp区别",
          "charIndex": 117
        },
        {
          "level": 2,
          "title": "TCP与UDP的适用场景",
          "slug": "tcp与udp的适用场景",
          "normalizedTitle": "tcp与udp的适用场景",
          "charIndex": 130
        },
        {
          "level": 2,
          "title": "WebSocket",
          "slug": "websocket",
          "normalizedTitle": "websocket",
          "charIndex": 146
        },
        {
          "level": 2,
          "title": "HTTP",
          "slug": "http",
          "normalizedTitle": "http",
          "charIndex": 32
        },
        {
          "level": 3,
          "title": "HTTP 协议格式",
          "slug": "http-协议格式",
          "normalizedTitle": "http 协议格式",
          "charIndex": 169
        },
        {
          "level": 3,
          "title": "HTTP Method",
          "slug": "http-method",
          "normalizedTitle": "http method",
          "charIndex": 184
        },
        {
          "level": 3,
          "title": "HTTP Status code和Status text",
          "slug": "http-status-code和status-text",
          "normalizedTitle": "http status code和status text",
          "charIndex": 201
        },
        {
          "level": 3,
          "title": "HTTP Head (HTTP 头)",
          "slug": "http-head-http-头",
          "normalizedTitle": "http head (http 头)",
          "charIndex": 235
        },
        {
          "level": 3,
          "title": "HTTP Request Body",
          "slug": "http-request-body",
          "normalizedTitle": "http request body",
          "charIndex": 259
        },
        {
          "level": 2,
          "title": "HTTPS",
          "slug": "https",
          "normalizedTitle": "https",
          "charIndex": 280
        },
        {
          "level": 2,
          "title": "HTTP2",
          "slug": "http2",
          "normalizedTitle": "http2",
          "charIndex": 289
        }
      ],
      "excerpt": "<Boxx/>\n<p>TCP/UDP协议是<strong>传输层协议</strong>，主要解决数据如何在网络中传输，而HTTP是<strong>应用层协议</strong>，主要解决如何包装数据。</p>\n",
      "headersStr": "TCP TCP三次握手 ★ 为什么TCP客户端最后还要发送一次确认呢？ UDP TCP和UDP区别 TCP与UDP的适用场景 WebSocket HTTP HTTP 协议格式 HTTP Method HTTP Status code和Status text HTTP Head (HTTP 头) HTTP Request Body HTTPS HTTP2",
      "content": "TCP/UDP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。\n\n\n\n * TCP\n   * TCP三次握手 ★\n   * 为什么TCP客户端最后还要发送一次确认呢？\n * UDP\n * TCP和UDP区别\n * TCP与UDP的适用场景\n * WebSocket\n * HTTP\n   * HTTP 协议格式\n   * HTTP Method\n   * HTTP Status code和Status text\n   * HTTP Head (HTTP 头)\n   * HTTP Request Body\n * HTTPS\n * HTTP2\n\n\n\n简单理解： “IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的卡车，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。\n\n当然还有像SOCKET这种抽象层：TCP/IP网络的API。Socket（相当于码头/车站）是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\nTCP提供有保证的数据传输，UDP不提供，而HTTP就是基于TCP实现的应用层协议。\n\n\n# TCP\n\nTCP是一种面向连接的、可靠的传输层协议；\n\nTCP协议建立在不可靠的网络层 IP 协议之上，IP协议并不能提供任何可靠性机制，TCP的可靠性完全由自己实现；\n\nTCP采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制（别发的太快已保证对方能收到）；\n\n\n# TCP三次握手 ★\n\n* 第一次握手：客户端向服务器发送请求报文段，其中同步位SYN=1，序号SEQ=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；\n\n* 第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位SYN=1，确认号ACK=x+1，序号SEQ=y；\n\n* 第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ACK(ack=y+1)，进而完成三次握手。\n\n\n# 为什么TCP客户端最后还要发送一次确认呢？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n# UDP\n\nUDP是一种无连接的、不可靠的传输层协议； 提供了有限的差错检验功能；目的是希望以最小的开销来达到网络环境中的进程通信目的。\n\nUDP（用户数据报协议）- 类似发短信：\n\n 1. 只管发送，不确认对方是否接收到\n 2. 将数据及源和目的封装成数据包中，不需要建立连接\n 3. 每个数据包的大小限制在64K之内\n 4. 因为无需连接，因此是不可靠协议\n 5. 不需要建立连接，速度快\n\n随着现代网速的提升，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP ， 如网页浏览、流媒体、实时游戏、物联网。\n\n\n# TCP和UDP区别\n\nTCP：\n\n面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂， 每一条TCP连接只能是点到点的， TCP首部开销20字节。\n\nUDP：\n\n面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ， UDP支持一对一，一对多，多对一和多对多的交互通信， UDP的首部开销小，只有8个字节。\n\n\n# TCP与UDP的适用场景\n\n 1. TCP用于在传输层有必要实现可靠传输的情况。\n\n 2. UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。\n    \n    举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用UDP，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。\n\n\n# WebSocket\n\n可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。\n\nHTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。\n\nWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n\n# HTTP\n\nHTTP 标准由 IETF 组织制定。\n\nHTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 模式。这个模式决定了通讯必定由浏览器端首先发起。\n\nHTTP 是存粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。\n\n\n# HTTP 协议格式\n\n\n\n\n# HTTP Method\n\n * GET：浏览器通过地址栏访问页面都是 GET 方法。\n * POST：表单提交产生 POST 方法。\n * HEAD：HEAD 跟 GET 类似，只返回请求头，多数由 JavaScript 发起。\n * PUT：添加资源，语义上的约束。\n * DELETE ：删除资源，语义上的约束。\n * CONNECT：CONNECT 多用于 HTTPS 和 WebSocket。\n * OPTIONS：一般用于调试，多数线上服务都不支持。\n * TRACE：一般用于调试，多数线上服务都不支持。\n\n\n# HTTP Status code和Status text\n\n * 1xx：临时回应，表示客户端请继续，被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓\n\n * 2xx：请求成功\n   \n   * 200：请求成功\n\n * 3xx：表示请求的目标由变化，希望客户端进一步处理\n   \n   * 301&302：当前资源已经被转移，永久性与临时性的转移。 301 更接近一种报错，提示客户端下次别来了。\n   * 304：客户端本地已经由缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。\n\n * 4xx：客户端请求错误\n   \n   * 403：无权限\n   * 404：表示请求的页面不存在\n\n * 5xx：服务端请求错误\n   \n   * 500：服务端错误\n   * 503：服务端暂时性错误，可以一会再试\n\n\n# HTTP Head (HTTP 头)\n\n> 可以看作键值对。\n\nRequest Header\n\nREQUEST HEADER      规定\nAccept              浏览器端接受的格式\nAccept-Encoding     浏览器端接受的编码方式\nAccpet-Language     浏览器端接受的语言，用于服务器端判断多语言\nCache-Control       控制缓存的时效性\nConnection          连接方式，如果是 keep-alive，且服务器端支持，则会复用连接\nHost                HTTP访问使用的域名\nIf-Modified-Since   上次访问时的更改时间，如果服务器认为此时间后自己没有更新，则会给出 304 响应\nIf-None-Match       上次访问时使用的 E-Tag，通常是页面的信息摘要，这个比更改时间更准确一些\nUser-Agent          客户端标识\nCookie              客户端存储的 Cookie 字符串\n\nResponse Header\n\nRESPONSE HEADER    规定\nCache-Control      缓存控制，用于通知各级缓存保存的时间，例如 max-age=0 表示不要缓存\nConnection         连接类型，Keep-Alive表示复用连接\nContent-Encoding   内容编码方式，通常是gzip\nContent-Length     内容的长度，有利于浏览器判断内容是否已经结束\nContent-Type       内容类型，所有请求网页的都是 text/html\nDate               当前的服务器日期\nETag               页面的信息摘要，用于判断是否需要重新到服务器端取回页面\nExpires            过期时间，用于判断下次请求是否需要到服务器端取回页面\nKeep-Alive         保持连接不断时需要的一些信息，如 timeout=5，max=100\nLast-Modified      页面上次修改的时间\nServer             服务器软件的类型\nSet-Cookie         设置 cookie 可以存在多个\nVia                服务器端的请求链路，对一些调试场景至关重要的一个头\n\n\n# HTTP Request Body\n\n> HTTP 请求的 body 主要用于提交表单场景。比较自由，服务端认可即可。\n\n常见的 body 格式：\n\n * application/json\n * application/x-www-form-urlencoded\n * multipart/form-data\n * text/xml\n\n使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 数据格式，当由文件上传时，则使用 multipart/form-data。\n\n\n# HTTPS\n\n> 在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。\n\nHTTPS 作用：\n\n * 确定请求的目标服务端身份\n * 保证传输的数据不会被网络中间节点窃听或者篡改\n\nHTTPS 是使用加密通道来传输 HTTP 的内容。 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。\n\n\n# HTTP2\n\n> HTTP 2 是 HTTP 1.1 的升级版本。\n\nHTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接推送。\n\n服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致性能问题。\n\nTCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。",
      "normalizedContent": "tcp/udp协议是传输层协议，主要解决数据如何在网络中传输，而http是应用层协议，主要解决如何包装数据。\n\n\n\n * tcp\n   * tcp三次握手 ★\n   * 为什么tcp客户端最后还要发送一次确认呢？\n * udp\n * tcp和udp区别\n * tcp与udp的适用场景\n * websocket\n * http\n   * http 协议格式\n   * http method\n   * http status code和status text\n   * http head (http 头)\n   * http request body\n * https\n * http2\n\n\n\n简单理解： “ip”代表网际协议，tcp和udp使用该协议从一个网络传送数据包到另一个网络。把ip想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。tcp和udp是高速公路上的卡车，它们携带的货物就是像http，文件传输协议ftp这样的协议等。\n\n当然还有像socket这种抽象层：tcp/ip网络的api。socket（相当于码头/车站）是应用层与tcp/ip协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把tcp/ip层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\ntcp提供有保证的数据传输，udp不提供，而http就是基于tcp实现的应用层协议。\n\n\n# tcp\n\ntcp是一种面向连接的、可靠的传输层协议；\n\ntcp协议建立在不可靠的网络层 ip 协议之上，ip协议并不能提供任何可靠性机制，tcp的可靠性完全由自己实现；\n\ntcp采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制（别发的太快已保证对方能收到）；\n\n\n# tcp三次握手 ★\n\n* 第一次握手：客户端向服务器发送请求报文段，其中同步位syn=1，序号seq=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；\n\n* 第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位syn=1，确认号ack=x+1，序号seq=y；\n\n* 第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ack(ack=y+1)，进而完成三次握手。\n\n\n# 为什么tcp客户端最后还要发送一次确认呢？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于tcp的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n# udp\n\nudp是一种无连接的、不可靠的传输层协议； 提供了有限的差错检验功能；目的是希望以最小的开销来达到网络环境中的进程通信目的。\n\nudp（用户数据报协议）- 类似发短信：\n\n 1. 只管发送，不确认对方是否接收到\n 2. 将数据及源和目的封装成数据包中，不需要建立连接\n 3. 每个数据包的大小限制在64k之内\n 4. 因为无需连接，因此是不可靠协议\n 5. 不需要建立连接，速度快\n\n随着现代网速的提升，udp协议以其简单、传输快的优势，在越来越多场景下取代了tcp ， 如网页浏览、流媒体、实时游戏、物联网。\n\n\n# tcp和udp区别\n\ntcp：\n\n面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂， 每一条tcp连接只能是点到点的， tcp首部开销20字节。\n\nudp：\n\n面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ， udp支持一对一，一对多，多对一和多对多的交互通信， udp的首部开销小，只有8个字节。\n\n\n# tcp与udp的适用场景\n\n 1. tcp用于在传输层有必要实现可靠传输的情况。\n\n 2. udp主要用于那些对高速传输和实时性有较高要求的通信或广播通信。\n    \n    举一个通过 ip 电话进行通话的例子。如果使用 tcp，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用udp，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。\n\n\n# websocket\n\n可以把websocket想象成http(应用层)，http和socket什么关系，websocket和socket就是什么关系。\n\nhttp 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。\n\nwebsocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n\n# http\n\nhttp 标准由 ietf 组织制定。\n\nhttp 协议是基于 tcp 协议出现的，对 tcp 协议来说，tcp 协议是一条双向的通讯通道，http 在 tcp 的基础上，规定了 request-response 模式。这个模式决定了通讯必定由浏览器端首先发起。\n\nhttp 是存粹的文本协议，它是规定了使用 tcp 协议来传输文本格式的一个应用层协议。\n\n\n# http 协议格式\n\n\n\n\n# http method\n\n * get：浏览器通过地址栏访问页面都是 get 方法。\n * post：表单提交产生 post 方法。\n * head：head 跟 get 类似，只返回请求头，多数由 javascript 发起。\n * put：添加资源，语义上的约束。\n * delete ：删除资源，语义上的约束。\n * connect：connect 多用于 https 和 websocket。\n * options：一般用于调试，多数线上服务都不支持。\n * trace：一般用于调试，多数线上服务都不支持。\n\n\n# http status code和status text\n\n * 1xx：临时回应，表示客户端请继续，被浏览器 http 库直接处理掉了，不会让上层应用知晓\n\n * 2xx：请求成功\n   \n   * 200：请求成功\n\n * 3xx：表示请求的目标由变化，希望客户端进一步处理\n   \n   * 301&302：当前资源已经被转移，永久性与临时性的转移。 301 更接近一种报错，提示客户端下次别来了。\n   * 304：客户端本地已经由缓存的版本，并且在 request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。\n\n * 4xx：客户端请求错误\n   \n   * 403：无权限\n   * 404：表示请求的页面不存在\n\n * 5xx：服务端请求错误\n   \n   * 500：服务端错误\n   * 503：服务端暂时性错误，可以一会再试\n\n\n# http head (http 头)\n\n> 可以看作键值对。\n\nrequest header\n\nrequest header      规定\naccept              浏览器端接受的格式\naccept-encoding     浏览器端接受的编码方式\naccpet-language     浏览器端接受的语言，用于服务器端判断多语言\ncache-control       控制缓存的时效性\nconnection          连接方式，如果是 keep-alive，且服务器端支持，则会复用连接\nhost                http访问使用的域名\nif-modified-since   上次访问时的更改时间，如果服务器认为此时间后自己没有更新，则会给出 304 响应\nif-none-match       上次访问时使用的 e-tag，通常是页面的信息摘要，这个比更改时间更准确一些\nuser-agent          客户端标识\ncookie              客户端存储的 cookie 字符串\n\nresponse header\n\nresponse header    规定\ncache-control      缓存控制，用于通知各级缓存保存的时间，例如 max-age=0 表示不要缓存\nconnection         连接类型，keep-alive表示复用连接\ncontent-encoding   内容编码方式，通常是gzip\ncontent-length     内容的长度，有利于浏览器判断内容是否已经结束\ncontent-type       内容类型，所有请求网页的都是 text/html\ndate               当前的服务器日期\netag               页面的信息摘要，用于判断是否需要重新到服务器端取回页面\nexpires            过期时间，用于判断下次请求是否需要到服务器端取回页面\nkeep-alive         保持连接不断时需要的一些信息，如 timeout=5，max=100\nlast-modified      页面上次修改的时间\nserver             服务器软件的类型\nset-cookie         设置 cookie 可以存在多个\nvia                服务器端的请求链路，对一些调试场景至关重要的一个头\n\n\n# http request body\n\n> http 请求的 body 主要用于提交表单场景。比较自由，服务端认可即可。\n\n常见的 body 格式：\n\n * application/json\n * application/x-www-form-urlencoded\n * multipart/form-data\n * text/xml\n\n使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 数据格式，当由文件上传时，则使用 multipart/form-data。\n\n\n# https\n\n> 在 http 协议的基础上，https 和 http2 规定了更复杂的内容，但是它基本保持了 http 的设计思想，即：使用上的 request-response 模式。\n\nhttps 作用：\n\n * 确定请求的目标服务端身份\n * 保证传输的数据不会被网络中间节点窃听或者篡改\n\nhttps 是使用加密通道来传输 http 的内容。 https 首先与服务端建立一条 tls 加密通道。tls 构建于 tcp 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，https 跟 http 没有任何区别。\n\n\n# http2\n\n> http 2 是 http 1.1 的升级版本。\n\nhttp 2.0 最大的改进有两点，一是支持服务端推送，二是支持 tcp 连接推送。\n\n服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致性能问题。\n\ntcp 连接复用，则使用同一个 tcp 连接来传输多个 http 请求，避免了 tcp 连接建立时的三次握手开销，和初建 tcp 连接时传输窗口小的问题。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2021/09/26, 14:11:36",
      "lastUpdatedTimestamp": 1632636696000
    },
    {
      "frontmatter": {
        "layout": "Tags",
        "title": "Tags"
      },
      "regularPath": "/tag/",
      "key": "v-b1564aac",
      "path": "/tag/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "FrontmatterKey",
        "title": "Categories"
      },
      "regularPath": "/categories/",
      "key": "v-ef9325c4",
      "path": "/categories/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "TimeLines",
        "title": "Timeline"
      },
      "regularPath": "/timeline/",
      "key": "v-6319eb4e",
      "path": "/timeline/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "随笔 Tags"
      },
      "regularPath": "/tag/%E9%9A%8F%E7%AC%94/",
      "key": "v-1eedfa34",
      "path": "/tag/随笔/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "ECharts Tags"
      },
      "regularPath": "/tag/ECharts/",
      "key": "v-5e43a71f",
      "path": "/tag/ECharts/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "vuepress Tags"
      },
      "regularPath": "/tag/vuepress/",
      "key": "v-dfb71430",
      "path": "/tag/vuepress/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "Via Tags"
      },
      "regularPath": "/tag/Via/",
      "key": "v-3247b8aa",
      "path": "/tag/Via/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "JavaScript Tags"
      },
      "regularPath": "/tag/JavaScript/",
      "key": "v-7a5f6990",
      "path": "/tag/JavaScript/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "json Tags"
      },
      "regularPath": "/tag/json/",
      "key": "v-14722046",
      "path": "/tag/json/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "Vue Tags"
      },
      "regularPath": "/tag/Vue/",
      "key": "v-32475d9a",
      "path": "/tag/Vue/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "网络协议 Tags"
      },
      "regularPath": "/tag/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/",
      "key": "v-3c2760d0",
      "path": "/tag/网络协议/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "随笔 Essay Categories"
      },
      "regularPath": "/categories/%E9%9A%8F%E7%AC%94%20Essay/",
      "key": "v-ab316f34",
      "path": "/categories/随笔 Essay/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "前端 Front-end Categories"
      },
      "regularPath": "/categories/%E5%89%8D%E7%AB%AF%20Front-end/",
      "key": "v-60e851e2",
      "path": "/categories/前端 Front-end/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "规范 Standard Categories"
      },
      "regularPath": "/categories/%E8%A7%84%E8%8C%83%20Standard/",
      "key": "v-e09e3912",
      "path": "/categories/规范 Standard/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 2 - 随笔 | Tags"
      },
      "regularPath": "/tag/%E9%9A%8F%E7%AC%94/page/2/",
      "key": "v-7c1bf909",
      "path": "/tag/随笔/page/2/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 2 - 随笔 Essay | Categories"
      },
      "regularPath": "/categories/%E9%9A%8F%E7%AC%94%20Essay/page/2/",
      "key": "v-a7aca2d2",
      "path": "/categories/随笔 Essay/page/2/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "主页",
        "link": "/index.html",
        "icon": "reco-home"
      },
      {
        "text": "时间线",
        "link": "/timeline/",
        "icon": "reco-date"
      },
      {
        "text": "关于我",
        "link": "/about/",
        "icon": "reco-message"
      }
    ],
    "sidebar": {
      "/views/": [
        "",
        {
          "title": "🏹 前端 Front-end",
          "collapsable": true,
          "children": [
            "frontend/EChartsStudy",
            "frontend/js-json",
            "frontend/viaStart",
            "frontend/vue-demo",
            "frontend/reco-info",
            "frontend/vuepress-plugin-boxx",
            "frontend/TCP&UDP"
          ]
        },
        {
          "title": "🔗 随笔 Essay",
          "collapsable": true,
          "children": [
            "essay/20190928",
            "essay/20191109",
            "essay/20191116",
            "essay/20191130",
            "essay/20200227",
            "essay/20200301",
            "essay/20200703",
            "essay/20200715",
            "essay/20200813",
            "essay/20201012",
            "essay/20201119",
            "essay/20211216",
            "essay/20220808",
            "essay/20230605"
          ]
        }
      ]
    },
    "authorAvatar": "/vuepress/head-fish.jpg",
    "search": true,
    "searchMaxSuggestions": 10,
    "smoothScroll": true,
    "sidebarDepth": 2,
    "blogConfig": {
      "category": {
        "location": 2,
        "text": "分类"
      },
      "tag": {
        "location": 3,
        "text": "标签"
      }
    }
  }
}